[{"id":0,"href":"/upload/prepare/","title":"上传前准备","section":"上传","content":" 一、前提条件 # 1）拥有 VRChat 账号（官网注册） # Steam 登录的不行，如果名字后面有其他字符说明是 steam 登录，请官网注册账号并绑定\n2）账号等级达到蓝色（New User） # 在线时间，经常去人多的地方，好友数量，和好友在一起等都会加速升级\n二、Unity 的下载与安装 # 1）打开 Unity 官网下载界面 # 官网下载界面链接 (CN)： Unity 所有版本下载 - Unity 中国官网\n条件允许建议下载国际版，但中国版也不是不能用\n2）下载Unity Hub并安装 # 下载Unity需要先注册登录才行\n3）下载 Unity2019.4.31（从 Unity Hub 下载可方便汉化） # 如果从Unity Hub下载，可以在可选组件里选择简体中文，忘记选择也没关系，后面文章会有方法\n当前 VRChat 的 SDK 支持的 Unity 版本是 2019.4.31f1，可在此查看： Currently Supported Unity Version (vrchat.com)\n三、VRChat SDK 的下载 # 1）打开 VRChat SDK 下载界面（需登录） # VRChat 下载界面链接： Download – VRChat\n2）下载SDK3.0 # 点击“Download SDK3 – Avatars”即可开始下载 注：部分老模型为SDK2的，可能需要下载SDK2(在“Other”里)，但建议升级SDK3上传（后续文章会介绍）\n四、必要插件的下载 # 一、动骨插件 # 点击下载： Dynamic Bone 1.2.0\n二、着色器插件 # 点击下载： UTS2\n三、其他 # 其他插件请自行探索，如： VRC 工具箱等\n"},{"id":1,"href":"/%E9%A6%96%E9%A1%B5/","title":"首页","section":"Docs","content":" 公告\n学业繁忙，不再更新维护，请勿问我问题，不会回复！因为我也不会\n说明/目录 # VRC Avatar Descriptor VRChat描述文件的介绍 PhysBones VRChat动骨的介绍 Contacts VRChat交互的介绍 State Behaviors VRChat提供的状态机脚本的介绍 Cloth Unity布料 Particle System Unity粒子系统 Trail Renderer Unity轨迹渲染器 Animation 动画的制作 Parameters 数值的类型与官方数值 Animator Layers Unity动画器的图层 VRChat Menu VRChat的菜单 上传：这部分是模型的上传 上传前准备 成品模型上传 MMD模型转为FBX MMD模型上传 SDK2转为SDK3 修改：这部分是简单的修改 添加默认图层与菜单 Base层-蹲姿，趴姿 Action层-AFK FX层-物品开关 附加：修改的附加部分 物体绑骨 换衣服 固定世界物品 固定世界MMD 手势开关 表情：表情制作相关 添加手势表情 Blender添加形态键 一键复制 脚本：此部分修改使用了VRC的脚本 自身跳MMD舞蹈 随机播放音乐 顺序播放音乐 出场动画 其他：其他修改 添加一个可以写字的笔 Blender换头 PC下移动手 关于 参考资料 原本只是说明，考虑到手机端不是太方便观看便加上目录\n另外我VRChat的ID为 yexca\n放出 ID 只是防止被冒充\n待办 # 以下是通过评论或私信或其他渠道希望我做的相关内容，说实话与其等我写出来不如自己去研究 (等我做出来自己早就精通了)\n按照时间顺序排列，已经做好就不放链接了，左上角有搜索\n斜体表示应该不会做，未标注原因则为没时间\nSDK描述文件(VRC Avatar Descriptor)的介绍 修改/制作表情动画 Blender换头 粒子系统（这个因个人能力有限，可能不会做视频） 顺序播放音乐 按手势 拔出和发射武器 更改自身亮度 制作动作动画 出场动画 换头发(我好像没有相关物品，可能做不了) 换颜色 多个头手势与嘴型 挥动武器显示特效 摇尾巴 Blender换衣服 弗利萨超行星特效 (这都什么玩意 "},{"id":2,"href":"/editing/playable_layers/","title":"添加默认图层与菜单","section":"修改","content":"如果是SDK3模型，可能已经有了数值和菜单，如没有参考以下操作\n动画层 # 为模型添加Base，Action和FX默认控制器\n如果是“SDK2转SDK3”或“MMD模型”，在“VRC Avatar Descriptor”的“Playable Layers”里点击“Customize”，然后在对应层后面点“Default 图层名”\n如果是SDK3模型，可能已经有了对应层，可以将没有的加入\n然后在“Assets\\VRCSDK\\Examples3\\Animation\\Controllers”可找到所有的默认控制器\nBase vrc_AvatarV3LocomotionLayer.controller Action vrc_AvatarV3ActionLayer.controller FX vrc_AvatarV3HandsLayer.controller 找到后点击并按“CTRL+D”即可克隆相同文件，可按“F2”重命名，然后可将这些文件拖入模型所在文件夹并新建一个文件夹存放。\n再将文件拖入“VRC Avatar Descriptor”的“Playable Layers”对应位置即可。\n数值与菜单 # 1）创建数值与菜单 # 可以在模型文件下新建一个文件夹用来存放数值与菜单\n在“Assets”里右击，依次选择“创建-VRChat-Avatars-Expression Parameters” ，并重命名为“数值”\n右击，依次选择“创建-VRChat-Avatars-Expression Menu” ，并重命名为“主菜单”\n2）为模型添加数值与菜单 # 如果是“SDK2转SDK3”或“MMD模型”，在“VRC Avatar Descriptor”的“Expression”里点击“Customize”，然后将刚创建的“菜单”拖入“Menu”，“数值”拖入“Parameters”\n"},{"id":3,"href":"/emote/emote_anim/","title":"添加手势表情","section":"表情","content":" 前言 # 本质是用模型的“Body”或“Face”的“BlendShapes”制作，如果没有，可能需要去一些建模软件进行添加\n一、要修改的动画 # 找到模型“FX层”，在图层“Left Hand”或“Right Hand”找到要修改的动画（可CTRL+D一个避免破坏原文件）\n以右手的“Point”为例\n二、修改动画 # 在“层级”中将模型“CTRL+D”，然后将原模型隐藏，把要修改的动画文件拖入复制的模型上，在“动画”窗口点击录制，然后找到模型的“Body”或“Face”的“BlendShapes”并展开修改相应数值完成表情制作\n**注意：**务必使用复制出的模型制作，不然可能会变得很奇怪\n在制作多个表情时，请将所有表情涉及到的BlendShaper的值设为0(除当前表情使用的)，防止表情冲突 图方便可以将所有BlendShaper设为0\n三、后续 # 关闭“录制”和“预览”，将制作好的动画替换原动画，复制的模型删除\n"},{"id":4,"href":"/other/vrlabs_marker/","title":"添加一个可以写字的笔","section":"其他","content":" 工具 # 这里使用VRLabs的免费商品： VRLabs Marker | マーカー – VRLabs – BOOTH\n前提 # 模型的数值可用位至少13\n模型的一级菜单至少一个可用位\n一、导入 # 下载解压后拖入即可，然后在项目“Assets-VRLabs-Marker”找到“Marker.cs”将其拖到“层级”中模型的名字上，然后点击模型名字即可在“检查器”看到脚本\n二、简介 # **Avatar：**显示要加入的模型名字，可替换\n**Left-handed：**装在左手上\n**Write Defaults：**动画层的东西，意为进入下一个状态时是否重置上一个状态所做的更改\n**Gesture to draw：**选择一个手势去写字，默认为point\n手势可参考： 数值\n**Adjustable brush size：**可调节画笔的大小\n**Adjustable eraser size：**可调节橡皮擦的大小\n**Use index finger to draw：**使用食指书写，启用则去掉笔\n**Enable local space：**允许将画出来的东西放在身体某部位\n**Half-Body：**上一项启用，允许放在半身，即头，手和胸\n**Full-Body：**在Half-Body的基础上加上脚部\n**Parameter memory bits needed：**需要数值大小，调整上方选项可能会改变\n**Generate Marker：**开始\n**Remove Marker：**移除\n三、创建 # 选择好后点击“Generate Marker” ，等待一会\n进入“播放”模式，在“Assets-VRLabs-Marker-Resources”找到控制器“M_Gesture”拖到模型控制器，然后点击脚本的第一个按钮“Adjust MarkerTarget transform”开始调整画笔的位置\n调整完成后，记录画笔的位置信息，然后退出播放模式填入\n调整完成点击“Finish Setup”即可\n移除 # 再次将脚本拖到模型上点击“Remove Marker”即可\n"},{"id":5,"href":"/additional/tied_bones/","title":"物体绑骨","section":"附加","content":" 简述 # 物品绑骨可以让物品随骨骼运动，例如眼镜绑定头部骨骼，剑绑定手部骨骼\n一、放在对应骨骼下方 # 在左方找到模型相应的骨骼，然后将物品拖进去即可，可调整位置\n例如将剑拖入手部骨骼下方，然后更改位置是剑柄放在手上\n注意：如果物品有骨骼，需要将物品骨骼放入模型骨骼(想要邦骨的位置，如剑的骨骼放手上)，其他的放入模型子集，不然模型骨骼会出错\n二、使用约束 # 点击要邦骨的物体，然后在“检查器”里“添加组件”，搜索“Parent Constraint”并添加\n可以先将物品移动到对应的位置(例如将剑柄移动至手上)\n在下方“源”，点击加号，然后将想绑定的骨骼拖入(例如手部骨骼)\n然后在“检查器”里点击激活即可\n"},{"id":6,"href":"/script/self_mmd/","title":"自身跳 MMD 舞蹈","section":"脚本","content":"(Animator Locomotion Control)\n一、文件准备 # 舞蹈动画文件 音乐 关于MMD舞蹈转换，请参考： 固定世界 MMD\n不过这里要调整动画方向，点击动画文件，在右方”跟变换旋转-依据“选择”原始“\n二、制作音乐开关 # 1）压缩音频 # 点击音频文件，在右方选择压缩格式(一般默认的 Vorbis 即可)，选择质量(越低压缩率越高)，然后点击应用即可\n2）加入音频 # 在模型上创建一个空物体，然后添加组件”音频源“(英文: Audio Source)\n在”AudioClip“后方拖入音乐，”空间混合“调为”1“，”多普勒级别“调为”0“，”音量衰减“选”线性衰减“，”最大距离“可自由调节(例如20)\n3）音频邦骨(可选) # 我制作一般会将音频邦骨在嘴部，邦骨参考： 物体绑骨\n4）制作音频开关 # 录制开关参考： FX 层-物品开关\n三、动画器添加动画 # Action 层 # 进入 Action 层，跟随 Entry-WaitForActionOrAFK-Prepare Standing，Prepare Standing 后连接八个过渡，任选一个过渡后的状态，将 Motion 替换为舞蹈动画\n然后添加组件 Animator Locomotion Control，将 Locomotion Control 设置为 Disable，如果不设置游戏中转动或移动时模型也会动\n检查前后过渡是否正确，是否有相应条件 (如前面为VRCEmote 等于 1，后面为 VRCEmote 不等于 1) 并且是否将退出时间关闭\n在下一个状态(“BlendOut Stand”)添加组件“Animator Locomotion Control”，将“Locomotion Control”设置为“Enable”，如果不设置游戏里再也无法移动或转动视角\nFX 层 # 进入FX层，在参数添加“Int”型参数，命名为“VRCEmote”\n创建一个层，音乐打开的条件为刚刚Action层进入舞蹈的条件(例如“VRCEmote”等于“1”)，关闭的条件为刚刚Action层退出舞蹈的条件(例如“VRCEmote”不等于“1”)，将退出时间关闭\n四、设置数值与菜单 # 数值 # 默认的数值第一个就是“VRCEmote”，如果没有请添加，类型为“Int”\n菜单 # 菜单添加一项，“类型”为“Toggle”，“Parameter”为“VRCEmote”，数值为在Action层条件(例如“1”)\n"},{"id":7,"href":"/upload/upload/","title":"成品模型上传","section":"上传","content":" 引言 # 成品模型指别人几乎什么都做好了的模型，自己只需要上传就行。 通常可在 Booth 上购买\n一、Unity 汉化准备 # 1）从 Unity Hub 安装简体中文组件 # 打开 Unity Hub 并登录，点击左方 安装，找到 2019.4.31f1c1 (c1 指中国版)，点击右方齿轮，选择 添加模块，找到 简体中文 后选择并安装\n2）没有“添加模块”或未从 Unity Hub 安装 # 注：此方法我未试过，不保证可以使用\n\u0026lt;1\u0026gt;下载 zh-cn.po 文件 # 下载链接： zh-cn.po\n\u0026lt;2\u0026gt;把文件放在 Unity 安装目录下 # C:\\Program Files\\Unity\\2019.4.31f1c1\\Editor\\Data\\Localization 如果没有这个目录请自己创建\n二、新建 Unity 工程并汉化 # 1）添加个人许可证 # 点击左上角头像处“管理许可证”，选择“添加-获取免费的个人版许可证-同意并获取个人版许可证”即可\n2）新建 Unity 工程 # 点击“新项目”，选择“3D”，命名工程，选择位置后点击“创建”，等待亿会即可\n3）汉化 # 如果想深入学习Unity建议使用英文原版\n在“Editor-Preferences-Languages”下选择“简体中文”\n三、导入文件 (unitypackage) # 导入文件可以双击或者直接拖入\n需要导入的文件 # 1）动骨插件 (Dynamic Bone 1.2.0.unitypackage)\n2）着色器插件 (UTS2.unitypackage)\n3）VRCSDK (VRCSDK3-AVATAR-2022.02.16.19.13_Public.unitypackage (新 SDK 更新啦，不是这个名字))\n4）模型文件\n四、上传模型 # 1）拖入模型 # 在下方 Assets 里找到 prefab 文件或场景文件\n\u0026lt;1\u0026gt;prefab 文件 # 拖入左方场景即可\n\u0026lt;2\u0026gt;场景文件 # 双击打开即可\n2）打开 VRC 控制面板 # 点击上方 VRChat SDK-Show Control Panel ，登录 VRChat 账号后点击 Builder\n\u0026lt;1\u0026gt;如果下方 “Build \u0026amp; Publish for Windows” 可以点击 # 直接点击然后等待亿会即可\n\u0026lt;2\u0026gt;如果不能点击 # 上方应该有六边形红色感叹号，每个后方应该都有 Auto Fix 把每个都点击然后点 Build \u0026amp; Publish for Windows 即可\n如果点完还不能上传，我还没遇到过\n\u0026lt;3\u0026gt;如果没有模型信息，显示 \u0026ldquo;A VRCAvatarDescriptor is required to build an Avatar\u0026rdquo; # 这种情况说明您上传的模型是 SDK2 的模型，请新建工程导入 SDK2 上传或升级为 SDK3 模型 (后面文章会有，推荐升级，说不定哪天 SDK2 模型就不被支持了)\n3）填写模型信息 # 等待创建成功后可以将 VRChat上传面板 关闭\nAvatar Name 即为模型的名字\nDescription 为模型的描述\n下一个警告不用管\nSharing 为上传模型是否公开，Private 为私密，Publish 为公开（即是否允许他人复制，一般选 Private）\n把最下方的复选框点上即可上传(点击 Upload)\n4）创建模型封面 # 上一步填完即可上传，但是右方图片可能我们并不满意\n\u0026lt;1\u0026gt;创建物体 # 回到场景，在左方 VRCCam 上右击选择 3D 对象-四边形\n右方的 Transform 中，位置的 z 轴填入 2.6，缩放的 x 轴和 y 轴分别填入 4 和 3\n\u0026lt;2\u0026gt;添加图片 # 找到一张想要上传的图片拖入 Unity，然后创建一个材质 (下方 Assets 右击 创建-材质)，点击材质，右方 Shader 选择一个，例 VRChat-Mobile-Toon Lit，然后将图片拖入右方材质里，然后将材质拖入 场景 里刚创建的四边形上即可\n\u0026lt;3\u0026gt;上传模型 # 这样操作后模型会挡到图片，可以在左方点击模型，右边模型名字旁(左边)有一个复选框，取消掉即可隐藏模型\n然后回到游戏界面，就可以在右方看到刚刚做的图片\n此时再次点击 Upload 即可\n五、遇到错误，上传失败 # 重启解决90%的问题，重装解决99%的问题，重买解决100%的问题\n重新上传，重新打开 Unity，新建工程上传，重启电脑，网络问题\n如果是蓝图问题 (错误信息有 BluePrint) ，可在左方点击角色，然后右方划到最底下点击 Detach 后重新上传即可\n"},{"id":8,"href":"/editing/base/","title":"Base 层-蹲姿，趴姿","section":"修改","content":" 一、Unity添加“动画器”窗口 # 在左上方“Window-动画-动画器”即可打开动画器窗口，可拖动放至任意位置(如“游戏”窗口右边)\n二、打开Locomotion层控制器 # 找到控制器所在位置点击即可在“动画器”窗口显示（可在左方点击模型名字后再在右方“VRC Avatar Descripor”找到Base层点击定位）\n三、修改站姿 # 在“Locomotion”层中找到“Standing”，点击后在右方“检查器”点击“Motion”后的“vrc_StandingLocomotion”即可定位，然后点击文件，替换掉“检查器”中“Motion”的第三个动画“proxy_stand_still”即可\n三、修改蹲姿 # 在“Locomotion”层中找到“Crouching”，点击后在右方“检查器”点击“Motion”后的“vrc_CrouchingLocomotion”即可定位，然后点击文件，替换掉“检查器”中“Motion”的第一个动画“proxy_crouch_still”即可\n四、修改趴姿 # 在“Locomotion”层中找到“Prone”，点击后在右方“检查器”点击“Motion”后的“vrc_ProneLocomotion”即可定位，然后点击文件，替换掉“检查器”中“Motion”的第一个动画“proxy_low_crawl_still”即可\n五、其他 # 其他姿势如跳跃姿势和下落姿势请自行研究\n"},{"id":9,"href":"/other/blender_change_head/","title":"Blender 换头","section":"其他","content":" 模型文件 # 将俩模型文件放入同一文件夹，如果有重名文件可重命名然后参考 问题进入软件后选择相应贴图\nBlender基本操作 # 鼠标中键：按住旋转\n鼠标滑轮：放大/缩小\nShift+鼠标中键：按住移动\nCTRL+鼠标中键：按住上下移动为放大/缩小\n一、导入第一个模型（头部） # 导入模型后如果是MMD模型请Fix Model，若不是进入下一步（Fix可能会出错）\n可以选择骨骼，按H以隐藏，方便观察\n然后点击CATS-Model Option-Separate by-材质以分离材质\n1）材质 # 头部和身体分开 # 直接将身体部分删除即可\n头部和身体连一起 # 选中衣服/身体，按TAB进入编辑模式\n使用鼠标左键点选或按住框选，按Shift+鼠标左键添加选择，按CTRL+鼠标左键取消选择\n框选个大概后，按CTRL+L选取连接的面\n然后按X-顶点以删除，然后按TAB以退出编辑模式进入物体模式\n重复至删除完毕\n2）骨骼 # 按ALT+H以显示所有隐藏的物品\n选中骨架，按TAB进入编辑模式\n选中一个上级骨骼，按Shift+G-子级，可选中当前骨骼的所有自己\n选中一个骨骼末端，按CTRL选中其他骨骼可从子级选中上级骨骼\n然后按X-骨骼即可删除骨骼，重复至删除完毕，然后按TAB以退出编辑模式进入物体模式\n在右上场景集合按A选取所有物品，然后按H以隐藏\n骨骼保留至Neck\n二、导入第二个模型（身体） # 和上一步差不多，不过是去掉头部\n问题：导入后材质/贴图不显示 # 选中模型，右下进入材质属性，选中缺失/异常的贴图\n滑倒最底部的MMD Texture，在Texture点击添加，选中相应贴图\n三、接头 # 1）大致位置 # 可以在物体模式下按Shift选择一些材质后按CTRL+J合并材质\n然后将头部移动到大致位置（可通过移动骨骼）\n选中骨骼，按G后按X/Y/Z以使其在X/Y/Z轴移动，点击即移动完成\n2）合并 # 在CATS-Custom Model Creation\n如果按此文章顺序进行(先身体后头部)，直接选择选择Merge Armatures\n若不是，Base/基础(基数)为头部，To Merge为身体\n3）分离脖子 # 先分离材质，点击CATS-Model Option-Separate by-材质\n头部需要分离一段脖子以防止破坏形态键\n选中头部，按TAB进入编辑模式，然后选择一圈脖子\n可按C键，然后鼠标左键拖拽选择，鼠标中键拖拽取消选择，鼠标右键退出\n选择完毕后按P-选中项将脖子分离出来\n去除形态键 # 然后按TAB退出编辑模式，进入物体模式\n选中分离出的脖子，在右下物体数据属性的形态键，按-删除所有形态键\n四、接面 # 可以隐藏其他东西，只显示脖子与身体方便观察\n可以先分别将俩进行删除部分以大致适配\n在物体模式按Shift选中俩后按CTRL+J合并材质，然后按TAB进入编辑模式\n选中俩顶点，然后按M-到中心，如果上下顶点不一可以选三个顶点\n1）粗细 # 选中两圈或多圈后鼠标右击-平滑顶点，多点几次，直到满意\n2）颜色 # 若头部与身体颜色相差过大，可进PhotoShop修改 （不会，不写啦）\n也可进入纹理绘制模式自行看看，例如使用涂抹工具\n五、测试 # 选中骨架，左上角进入姿态模式，然后旋转骨骼查看是否正常\n选中骨骼，按R后按X/Y/Z以使其在X/Y/Z轴旋转，点击即旋转完成，然后CTRL+Z撤销操作\n注：一般权重是对的，有些权重错误进Unity会变得正常\n六、权重 # 1）分离材质 # 为方便刷取权重，可以分离相关材质\n首先使用CATS-Model Option-Separate by-材质分离\n如果需要刷取的地方被分离可进入权重绘制，如果需要再分\n选取需要分的部分，按TAB进入编辑模式，选取需要分出来的部分后按P-选中项即可分离\n2）权重绘制 # 在物体模式下，选中骨架，然后按住Shift选择需要刷权重的部分，再在左上角进入权重绘制模式\n按CTRL+鼠标左键选择某骨骼可绘制该骨骼的权重\n"},{"id":10,"href":"/emote/add_blendershapes/","title":"Blender 添加形态键","section":"表情","content":" 导入模型 # 导入待加表情的模型，然后隐藏\n导入表情模型 # 分离材质，删除不需要的部分\n注意：如果原模型有形态键，需要将重名的改名或删除\n顶点组（非必须） # 此处作用：方便选择\n在编辑模式下选择一些点后，在顶点组新建并命名后点击指定\n删除：可选择删除全部组\n合并 # 将表情移动至模型，可右击-设置原点-原点-\u0026gt;几何中心，然后与模型的材质合并，Ctrl+J合并，然后将其余东西删除\n如果放不进去可以移动表情材质之间的位置\n编辑形态键 # 打开形态键编辑模式\n选择要编辑的形态键，将值(明度)调为1，然后在场景编辑即可\n闭眼张口 # 直接在模型上修改顶点位置\n瞳小 # 可先分离眼部材质后操作\n权重 # 进入姿态模式测试权重是否正确\n刷权重 # 在物体模式下，选中骨架，然后按住Shift选择需要刷权重的部分，再在左上角进入权重绘制模式\n按CTRL+鼠标左键选择某骨骼可绘制该骨骼的权重\n跟随眼睛动的眼睛权重全刷为1，上一级（Head）全刷为0\n不随眼睛动的眼睛为0，上一级（Head）为1\n自动刷？ # 注意：毕竟是机器，难免会识别错误\n左上角权重-自动按骨骼指定\n"},{"id":11,"href":"/div/vrc_avatar_descriptor/","title":"VRC Avatar Descriptor","section":"Docs","content":" 添加描述文件 # 在“层级”中选中模型名字即可在右方组件搜索添加“VRC Avatar Descriptor”\n第一个为VRC的描述，第二个为蓝图\n一、View # 用于调整视角球，即在游戏中看到的位置，一般放在两眼中间\n点击“Edit”即可在“场景”中调整位置，调整完成后点击“Return”\n二、LipSync # 定义后模型可在开麦说话时开口\n一般点击“Auto Detect!”可自动添加，如无法正常识别请手动添加\n一般“Mode”为第四个“Viseme Blend Shape” ，然后将模型的“Body”或“Face”拖入“Face Mesh” ，一般情况如下 (如识别不出请手动选择)\n若没有以上东西请禁用，即“Mode”选“默认”，或者自己研究骨骼实现\n三、Eye Look # 眼部相关，点击“Enable”开始更改\nGeneral # 全局设定眼部移动\n“Calm-Excited”影响眨眼的频率\n“Shy-Confident”影响自己的模型看向其他玩家模型的频率以及看向其他玩家时视线停留的时间\nEyes # Transforms # 定义眼骨的位置\n找到相应骨骼拖入即可，如没有请跳过\nRotation States # 定义眼部骨骼旋转的范围，只有当上一项填入眼骨才可用\n定义向前，上，下，左，右看时眼睛的移动\n点击“Preview”可进行编辑，可以在场景中进行旋转，点击“X”轴左方的链子可分别定义左右眼，当调整好后点击“Return”保存\nEyelids # 定义闭眼，向上看和向下看\n一般“Eyelid Type”选择“Blendshapes”，然后将“Body”或“Face”拖入“Eyelids Mesh”\n在“Blendshapes”可定义闭眼与向上看和向下看\n**注意：**此处向上看与向上看与上一项“Eyes-Rotation”中的向上看和向下看是相同的，若使用上方定义可选择“-none-”\n游戏中眼部出现异常可在这个模块调整，图省事可直接“disable”\nPlayable Layers # 在 SDK3 的 Avatar Descriptor 一共有五个层，分别为\nBase 或称Locomotion层，控制模型的蹲姿，趴姿等 Additive Base层的附加，例如制作呼吸动画 Gesture 手势层，手势动作制作，或者用于“空闲动画”，例如摇摆尾巴、拍打翅膀或移动耳朵 Action 动作层，例如MMD舞蹈放此层 FX 控制物品的开关，手势表情也在此层 此外，还有附加的三个层，分别为（此部分如需了解请看“ 官方文档”）\nT-Pose IK Pose Sitting Pose Lower Body # 第一个：头部有轻微移动会有小碎步的效果\n第二个：全身追踪时是否启用Locomotion\nExpressions # 数值\n菜单\nColliders # 新SDK3特有，用于定义头部、身体、手脚的碰撞\n点击“Edit”即可定义位置与大小，可在场景中进行编辑\n点击左方的链条即可分别设置左右位置\n此处设置的不仅是碰撞体积也是交互系统发送端的大小\n具体参考： 交互 (Contacts) 简介\n"},{"id":12,"href":"/additional/change_clothes/","title":"换衣服","section":"附加","content":" 一、适配衣服 # 1）已换好 # 部分模型的适配衣服在导入原模型后会有一个已换好衣服的文件，这时只需要录制一个动画关闭原衣服，打开新衣服再添加至FX层和菜单中即可\n2）自己换 # 首先将模型和衣服都拖入场景中，如果衣服和人物不在一起，请将两者位置都改为0，0，0\n在“层级”右击衣服，选择“解压缩预制件”，将衣服的文件(mesh，即除了骨骼之外的文件)拖入模型的自己\n将衣服的骨骼拖入模型骨骼对应位置子集\n然后做一个动画，关闭原衣服，打开新衣服\n将动画放入FX层和菜单中即可\n二、不适配衣服 # 1）CTRL+D模型 # 不适配衣服有可能在Unity中无法做到完美更换，因骨骼较多，建议先在“层级”中CTRL+D模型，在复制出的模型修改，若修改结果满意将原模型删除即可，反之删除复制模型\n2）Unity工具快捷键 # 以下是需要用到的快捷键\n移动工具：W 旋转工具：E 缩放工具：R 3）开始 # 首先将原模型隐藏，然后将复制的模型(下面将称“模型”)和要更换的衣服位置改为0，0，0\n在“层级”右击衣服，选择“解压缩预制件”，为方便调整可以把模型的原衣服隐藏\n调整衣服的大小(缩放)和位置使其大致适配模型\n4）调整 # 将衣服本体(mesh，即除了骨骼之外的文件)放到模型子集\n\u0026lt;1\u0026gt;外部调整 # 首先需要对其骨骼，在场景中模型胳膊肘处骨骼(Lower Arm L和Lower Arm R)要和衣服的相应位置骨骼的位置大致在一起，此处可通过使用缩放工具缩放衣服上一级骨骼(Upper Arm L和Upper Arm R)来实现（也可以移动过去，但移动的效果看起来不是太好）\n将模型一些可以弯曲的骨骼(例如胳膊肘，手，膝盖等)和衣服相应的骨骼对齐后可以将骨骼放入模型骨骼相应位置\n\u0026lt;2\u0026gt;内部调整 # 此时可以旋转一些部位观看是否绑定准确，如不满意可以试试使用工具\n如果此时不能改变满意，可以将衣服骨骼先从模型骨骼移出来调整\n5）完成 # 调整完成如果满意可以将原来的模型给删除，留下复制的模型，然后录制动画关闭原衣服，打开新衣服，再添加至FX层和菜单即可\n"},{"id":13,"href":"/script/shuffle_playback/","title":"随机播放音乐","section":"脚本","content":"(Avatar Parameter Driver)\n一、准备文件 # 已经录好开关音频的动画文件，可参考： 自身跳MMD舞蹈\n二、参数 # 参数 动画器(FX层) 数值 描述 开关(Bool) 例如“Music_Start” 添加 添加 控制随机播放开关 选择歌曲(Int) 例如”Music” 添加 可选(如果添加可在游戏显示 当前播放歌曲和切换下一首) 控制选择的歌曲 三、图层 # 参加参数后，新建一个图层，重命名后权重设为1，如下图所示\n四、菜单 # 在VRC数值中添加参数后制作菜单\n1）如果只是做一个开关 # 只需要添加一个“Toggle”，参数为“Music_Start”即可\n2）游戏中显示当前播放歌曲 # 建议做一个子菜单\n先添加一个开关，即添加一个“Toggle”，参数为“Music_Start”\n然后再添加几个(歌曲数量)“Toggle”，参数为“Music”，值为图层中对应条件\n3）添加下一首 # 其实做了游戏中显示当前播放歌曲后在游戏中点击任意歌曲即可切换\n所以可以添加一个“Toggle”，参数为“Music”，值为“0”或者其他都行\n五、其他 # 利用此脚本也可以实现顺序播放，倒序播放等\n也可以做一个招式(动画)的随机语音\n"},{"id":14,"href":"/editing/afk/","title":"Action 层 - AFK","section":"修改","content":" 一、什么是AFK # AFK为使用VR游玩VRChat时摘下头显模型会做出的动作，默认为打坐\nPC游玩可通过按”End“键进入AFK状态\n二、打开Action层控制器 # 找到控制器所在位置点击即可在“动画器”窗口显示（可在左方点击模型名字后再在右方“VRC Avatar Descripor”找到Action层点击定位）\n三、替换动画 # 将左下角的“Afk Init”, “AFK”和“BlendOut”替换为想要的动画\n一、想替换的动画文件只有一个 # 将这个动画放到“Afk Init”, “AFK”和“BlendOut”的”Motion“里\n二、待替换的文件有三个 # 请确定进入动画，退出动画\n进入动画放“Afk Init”的”Motion“\n退出动画放“BlendOut”的”Motion“\n第三个放“AFK”的”Motion“\n"},{"id":15,"href":"/upload/mmd_to_fbx/","title":"MMD 模型转为 FBX","section":"上传","content":" 引言 # MMD 模型不能被 Unity 识别，可以通过两种方法进行转换，本文借助 Blender 转换，借助插件转换请参考 将 MMD 模型导入 unity – yexca\u0026rsquo;Blog\n一、下载并安装Blender和插件 # 1）下载Blender2.93 # 官方下载链接： Index of /release/ (blender.org)\n请寻找2.93版本进行下载\n2）下载插件 # Github链接： Releases · absolute-quantum/cats-blender-plugin (github.com)\n文件直链\nGithub： cats-blender-plugin-0-19-0.zip\n3）安装插件 # 打开 Blender，选择常规，点击左上方编辑-偏好设置-插件-安装，找到插件下载目录后点击安装插件，然后在勾选上复选框启用即可\n二、导入模型并粗处理 # 1）清除物品 # 在右上角全选物品后按 delete 键或 x` 键删除\n2）导入模型 # 点击左上角文件-导入-MikuMikuDance Model，然后找到模型双击导入即可\n3）Fix 模型 # 右上角有个 \u0026lt; 点击展开菜单，点击 CATS，选择 Fix Model，等待亿会即可\n然后就可以导出啦(点击左上文件-导出-FBX 即可)\n三、进一步处理 # 上一步处理后虽然能用，但是在游戏里说话不会开口。\n1）眼部处理 # 如图设置\n点击”Create Eye Tracking“即可，如果未找到，请选择”基型“\n2）嘴部处理 # 如图所示\n点击”Create Visemes“即可\n3）导出 # 至此即可导出，点击左上”文件-导出-FBX“即可\n四、再进一步处理 # 下面的处理为分离材质，可以实现脱衣服之类的，如想实现此效果请注意第三步需要重做\n1）分离材质 # 在”Model Options“里点击材质，等待亿会即可分离材质\n2）确定Body # 右上角里可以通过点击眼睛来开关物品，确定身体所在的位置，重命名为”Body“\n3）合并材质 # 在右上方可以按”CTRL“选择想合并的部位，然后点击”Model Options“里”Join Meshes-Selected“即可\n当然，Body也可以合并，但必须叫”Body“，”表情“必须放进”Body“\n4）重做第三步 # 既然都做那么精细了，不加点第三步东西可不行啊\n"},{"id":16,"href":"/other/pc_arm_moving/","title":"PC 下移动手","section":"其他","content":"Two Axis Puppet\n动画 # 下载地址： PC_Arm_Moving.unitypackage\n原包我已经找不到了，而且我已经卸载 Unity，这是从我保留下来的工程文件找的，不知道是否可用\nArm_Rigth # 注：此演示退出不重置\n数值 Bool：Arm_Right_Toggle，Reset_Right\nFloat：Arm_1，Arm_2\n图层 添加Avatar遮罩\nDefault - Arm_Right_Toggle=True - BlendTree - Reset_Right=True - Resrt - Reset_Right=False - Default\nBlendTree Arm_1，Arm_2\n2D Freeform Directional(二维自由定向)\n6个Add Motion Field\nMotion Pos X Pos Y ArmDefault 0 0 ArmLeft -1 0 ArmRight 1 0 ArmUp 0 1 ArmDown 0 -1 ArmRightUpLeft -0.75 0.75 菜单 一、\nType：Two Axis Puppet\nParameter：Arm_Right_Toggle\nParameter Horizontal：Arm_1\nParameter Vertical：Arm_2\n二、\nType：Button\nParameter：Reset_Right\nArm_Both # 注：此演示退出即重置\n数值 Bool：Arm_Both_Toggle\nFloat：Arm_1，Arm_2\n图层 添加Avatar遮罩\nDefault - Arm_Both_Toggle=True - BlendTree\nBlendTree - Arm_Both_Toggle=False - Default\nBlendTree Arm_1，Arm_2\n2D Freeform Directional(二维自由定向)\n7个Add Motion Field\nMotion Pos X Pos Y ArmBothDefault 0 0 ArmBothLeft -1 0 ArmBothRight 1 0 ArmBothUp 0 1 ArmBothDown 0 -1 ArmBothUpLeft -0.5 0.5 ArmBothLeftDown -0.5 -0.5 菜单 Type：Two Axis Puppet\nParameter：Arm_Both_Toggle\nParameter Horizontal：Arm_1\nParameter Vertical：Arm_2\n"},{"id":17,"href":"/dynamics/physbones/","title":"PhysBones","section":"Docs","content":" 官方消息\n原动骨插件最终将被全部移除，将全部自动转为新动骨\n关于自动转换 # 将带动骨的模型拖入场景，选择模型后点击上方“VRChat SDK-Utilities-Convert DynamicBones to PhysBones”\n注意：毕竟只是自动转换，Dynamic Bones和PhysBones并不相同，肯定会有不完美的地方 (指很多bug)\n添加PhysBones # 在想要“动”的骨骼(例如头发，裙子等)上添加组件“VRC Phys Bone”即可\n添加组件后可以看到模型上有白线，就是“静止位置”\n以下所述内容建议亲自尝试，毕竟文字表述没有自己上手实验所带来的视觉反馈强\n一、Transforms # Root Transform # 动骨的根位置，若不添加则为组件所在位置\nIgnore Transforms # 如果动骨所在位置下方有子骨骼，但部分子骨骼不想让它跟着此动骨动，可将其拖到此处\n例如：尾巴在裙子骨骼下，不想尾巴”动”的效果和裙子一样可拖入此处\nEndpoint Position # 动骨结束位置，一般不需要设置。(在骨骼末端创建额外的骨骼)\n需要设置的情况：例如裙子很长但只有一个骨骼，可修改此项使动骨达到裙子末端一般只需要动“Y轴”，而且是个正值，具体如下：\n一般裙子骨骼如下(不需要设置) 只有一个骨骼(可能需要设置) 父级“Hips”下子集“Skirt_A1_L”还有子集 父级“Hips”下子集“Skirt1”无子集 Multi Child Type # 当前骨骼多子骨骼情况下，父级骨骼位置，一般“忽略”即可\n忽略：不添加骨骼\nFirst：子骨骼中第一个骨骼作为父骨骼的终点\nAverage：所有子骨骼的起点的平均位置作为父骨骼的重点\n二、Forces # Integration Type # 选择简单模式或高级模式，此部分数值可以在播放模式调整测试效果\n关于后面的C：数值将根据设定的曲线改变\n简单(Simplified)高级(Advanced) 较稳定，容易配置，对外部冲击和力量反应较小 不稳定，但允许更复杂的配置，对外部冲击和力量反应敏感 Pull(拉力) 将动骨拉回“静止位置”的力量，数值越大，力量越大(裙子越不容易动) Spring(弹性) Momentum 动骨回到“静止位置”的摇晃程度 同Spring，具体效果请自行尝试 \u0026nbsp; 硬度(Stiffness) \u0026nbsp; 使动骨保持在“静止位置”的强度，值越大越强 Immobile 动骨对骨骼的影响程度。值为1时不影响骨骼，即骨骼一直在“静止位置”，只有碰撞和抓取时才生效 重力(Gravity) 重力对骨骼影响，小于0则反重力(裙子上飘) Gravity Falloff(重力衰减) 只有在上一项“重力”不为0时可用，控制重力对动骨“静止位置”的影响，值为1时不影响 参考参数 # 来源： https://youtu.be/PTTnWUkswkU\n三、Limits(限制) # 此部分为动骨移动范围的限制，可以用于防穿模，比碰撞更高效\n当添加限制时，在场景里有一个可视化图形用于辅助，此部分数值调整可在场景看到效果\n若为无(None)则没有限制\n1）角度(Angle) # 骨骼移动范围为圆锥型\nMax Angle：最大角度\nRotation：调节限制的范围，具体自己调节即可知晓\nPitch(俯仰)：Y-Z轴平面调整\nRoll(旋转)：X-Z轴平面调整\nYaw(偏移)：X-Y轴平面调整\n2）Hinge(合页) # 骨骼移动范围为一个平面\nMax Angle：最大角度\nRotation：参考 角度 (Angle)的介绍\n3）Polar # 在上一个类型“Hinge(合页)”的基础上多一个轴可移动，不过此类型占用性能过大，官方建议尽量避免使用\nMax Pitch：可移动角度，类似“Hinge(合页)”的“Max Angle”\nMax Yaw：新轴的范围\nRotation：参考 角度 (Angle)的介绍\n四、Collision(碰撞) # 半径(Radius)：碰撞球的半径\nAllow Collision：勾选则允许其他玩家碰撞(触碰)此骨骼\n碰撞器(Colliders)：如添加其他骨骼碰撞，则会显示于此，如将腿部碰撞拖入裙子动骨此处。大小为数量\n添加碰撞 # 添加碰撞在相应骨骼下创建空物体后添加组件“VRC Phys Bone Collider” (例如腿部骨骼添加空物体“腿部碰撞”)\nRoot Transform：碰撞所在位置，不添加则为组件所在位置\nShape Type：类型，可以选“球体”、“胶囊”或“平面”\nInsider Bounds：勾选则相应动骨只能在此范围内运动\n推荐使用**Insider Bounds(内碰撞)**添加，更好的控制动骨移动范围，防止穿模 个人见解：小范围移动用外碰撞，大范围移动用内碰撞\n碰撞添加至动骨 # 直接将此空物体拖入动骨的碰撞器即可(例如腿部碰撞拖入裙子动骨)\n作用 # 防穿模，播放模式下可看到效果(例如裙子被腿部碰撞撑起来)\n五、Grab \u0026amp; Pose(抓取和定位) # Allow Grabbing：允许其他玩家抓取此骨骼\nAllow Posing：允许其他玩家抓取后将其定位\nGrab Movement：控制抓取的骨骼如何移动。数值为”0″将通过“Forces”设置参数移动，数值为“1”则立即移动\nMax Stretch：骨骼被抓取时可以被拉伸的最大长度\n六、Options # 参数(Parameter) # 此处设置一个字符串可创建一些参数(将填入数值替换下方{parameter})用于实现一些效果\n{parameter}_IsGrabbed：Bool类型，骨骼是否被抓住\n{parameter}_Angle：Float类型，取值0.0~1.0，骨骼被扭转的角度，如果被扭转180度即和原骨骼方向相反则为1.0\n{parameter}_Stretch：Float类型，取值0.0~1.0，骨骼被拉伸的长度与最大长度的百分比，如最大长度为10，当被拉到5时，此参数为0.5\n例如在“参数(Parameter)”后填入“Hello”，想要使用这些参数则使用“Hello_IsGrabbed”、“Hello_Angle”和“Hello__Stretch”\nIs Animated # 允许骨骼变换被动画控制，骨骼的“静止位置”将允许被动画改变\n七、Gizmos # Show Gizmos：显示动骨和限制\nBone Opacity：骨骼不透明度，值为0透明(看不见)，值为1不透明(最清晰)\nLimit Opacity：限制不透明度，同上\n八、注意事项 # 一个动骨插件最大可实现256个变化，如果骨骼过多，请分开加动骨组件，不要直接在根骨骼添加组件 (不会真有人这么加吧，不会吧)\n"},{"id":18,"href":"/additional/set_object/","title":"固定世界物品","section":"附加","content":" 一、使用预制件 # 1）下载并导入Unity # 点击下载： 稳定刚体\n下载后解压将整个文件夹拖入Unity中\n2）处理 # 找到prefab文件，将其拖入模型的子集，然后右击“解压缩预制件”\n将其中的“Anchor”拖到上一级，即模型的子集，可重命名(如“贝纳勒斯”)\n然后依次展开“worldSpace-Container-Cube” ，将“Cube”的“Mesh Renderer”组件移除，然后将模型移到“Cube”的下方\n文件名“worldSpace”也可重命名(如“贝纳勒斯_Model”)\n3）录制动画 # 录制一个动画将“worldSpace”打开即可(本例中”贝纳勒斯_Model”打开)\n二、不使用预制件 # 1）创建空物品 # 首先将模型的位置变为0，0，0，然后在模型下方创建一个空物体(右击 – “Create Empty”)\n再在空物体的子集创建五个空物品(创建一个后可“CTRL+D”)\n将五个空物体分别命名为“世界位置源”，“更新位置源”，“世界位置”，“更新位置”和“物品”，然后将“更新位置”放入“世界位置”的子集\n然后将模型放入“物品”的子集，可以移动模型，但“物品”不可以移动，位置要是0，0，0\n2）添加约束 # \u0026lt;1\u0026gt;世界位置的约束 # 点击“世界位置”，在右方添加“Position Constraint”和“Rotation Constraint”组件，然后添加源为“世界位置源”\n将“Position Constraint”的权重设为“0.5”，然后将俩组件的源的权重都设为“-1”\n最后都激活\n\u0026lt;2\u0026gt;更新位置的约束 # 点击“更新位置”，在右方添加“Parent Constraint”，添加源为“更新位置源”，然后点击激活\n\u0026lt;3\u0026gt;物品的约束 # 点击“物品”，在右方添加“Parent Constraint”，添加源为“更新位置”，然后点击激活\n3）制作动画 # 关闭动画：关闭“物品”，打开“更新位置”\n打开动画：打开”物品“，关闭”更新位置“\n4）动画器相关 # 新建图层，权重设为“1”，新建参数，类型为“Bool”\n在图层中，先将“关闭”动画拖入作为默认值，然后再拖入打开动画，创建过渡，过渡为新建的参数\n"},{"id":19,"href":"/script/play_in_order/","title":"顺序播放音乐","section":"脚本","content":"(Avatar Parameter Driver)\n一、准备文件 # 已经录好开关音频的动画文件，可参考： 自身跳MMD舞蹈\n二、参数 # 参数 动画器(FX层) 数值 描述 开关(Bool) 例如“Music_Start” 添加 添加 控制随机播放开关 选择歌曲(Int) 例如”Music” 添加 可选(如果添加可在游戏显示当前播放歌曲) 控制选择的歌曲 下一首(Bool) 例如“Next” 可选 可选(如果添加可控制播放下一首) 控制播放下一首 三、图层 # 参加参数后，新建一个图层，重命名后权重设为1，如下图所示\n四、菜单 # 在VRC数值中添加参数后制作菜单\n1）如果只是做一个开关 # 只需要添加一个“Toggle”，参数为“Music_Start”即可\n2）游戏中显示当前播放歌曲 # 建议做一个子菜单\n先添加一个开关，即添加一个“Toggle”，参数为“Music_Start”\n然后再添加几个(歌曲数量)“Toggle”，参数为“Music”，值为图层中对应条件\n3）添加下一首 # 添加一个“Button”，参数为“Next”\n"},{"id":20,"href":"/emote/pumkin_tools/","title":"一键复制","section":"表情","content":" Blender导出 # 材质不能修改，与原模型一样（可能骨骼也不能修改）\nPumkin\u0026rsquo;s Avatar Tools # Github：https://github.com/rurre/PumkinsAvatarTools\n文件直连：Github V1.1.1：https://github.com/rurre/PumkinsAvatarTools/releases/download/1.1.1/PumkinsAvatarTools_v1.1.1.unitypackage\n模型处理 # 将工具与模型导入Unity\n然后将模型骨骼改为Humanoid，材质为使用外部材质，然后可能需要去材质球处选择贴图，或使用原模型的材质球\n将模型拖入场景，打开Pumkin-Tools-Avatar Tools\n其中Avatar选择模型，在Copy Components-Copy From选择预制体\n然后点击Copy Selected即可\n"},{"id":21,"href":"/dynamics/contacts/","title":"Contacts","section":"Docs","content":" 前言 # 交互系统(Contacts)允许角色检测与自己或其他人的信号，然后可以使用这些信号产生的参数来触发动画\n注意：交互系统和动骨系统是不同的(我刚开始看搞混了)\n交互系统分为发送端(VRCContactSender)和接收端(VRCContactReceiver)。发送端是为了被检测而存在，即一直在广播自己的参数(Collision Tags)，接收端检测发送端，如果和发送端参数(Collision Tags)相同，则更新参数\n添加交互系统的组件 # 在物体或骨骼上添加组件搜索“vrc”，找到相应组件点击即可\nVRC Contact Sender(发送端) # 定义发送信号的体积和参数(Collision Tags)\nRoot Transform # 此组件所在位置，若为空则为组件所在物品\nShape(形状) # Shape Type：形状类型，可选“球体”和“胶囊”\n半径、位置、高度(“胶囊”)：字面意思\nRotation：旋转\nFiltering(过滤) # 调整和定义发送端如何与接收端交互\nCollision Tags：指定该发送端可以影响/受其影响的字符串列表，为了成功实现碰撞(被接收端成功检测)，发送端和接收端都需要至少一对匹配的字符串\n此处可选择默认的一些参数或者自定义参数，注意：字母区分大小写\n注意 # 在“VRC Avatar Descriptor”里有“Collidees”会设置头部、身体、手部和脚部的一些碰撞，这些设置默认是会有发送端的，发送参数为名字，例如“头部”为“Head”，因此无需将这些部位设置上发送端\nVRC Contact Receiver(接收端) # 定义接受信号的体积与参数(Collision Tags)，然后输出相应参数\nRoot Transform # 此组件所在位置，若为空则为组件所在物品\nShape(形状) # Shape Type：形状类型，可选“球体”和“胶囊”\n半径、位置、高度(“胶囊”)：字面意思\nRotation：旋转\nFiltering(过滤) # 定义如何与发送端交互\nAllow Self：允许自己触发，勾选即可以自己与自己交互\nAllow Others：允许他人触发，勾选即他人可以与自己交互\nLocal Only：仅在本地客户端上运行\nCollision Tags：指定可以接受的字符串列表/触发此交互的参数列表，为了成功实现碰撞(成功检测到发送端)，发送端和接收端都需要至少一对匹配的字符串\nReceiver # 定义接受到信号后所改变的参数，参数后填入名字即为要改变的参数\nReceiver Type(类型) 描述 数值 常量(Constant) 发生交互则改变参数 建议Bool，触发时为True 其他Float为1.0，Int为1 OnEnter 当进入速度大于Min Velocity时触发 建议Bool，触发时为True 其他Float为1.0，Int为1 Proximity 发送端到接收端中心的接近程度 如果多个发送端，值为最近的 Float，0.0~1.0 第三种“Proximity”如需要很高精准度，需要将发送端半径调到非常小\n"},{"id":22,"href":"/editing/switch/","title":"FX 层 - 物品开关","section":"修改","content":" 一、Unity添加“动画”窗口 # 在左上方“Window-动画-动画”即可打开动画器窗口，可拖动放至任意位置(如下方“控制台”窗口右边)\n二、在模型上添加物品 # 如果是导入的物品，和角色类似，直接在”Assets“里找到prefab文件或fbx文件拖入即可\n如果是Unity的物品(例如光源)，在左方”层级“右击选择即可(如”灯光-点光源“) 或者直接在模型名字上右击创建则只用调整位置即可\n拖入场景后可先调整到合适的位置\n然后再将左方”层级“中物品拖入模型的子集中（即拖到模型名字上，会自动归于模型下方）\n此时移动模型此物体也会移动\n三、录制物品打开动画 # 可以先在模型的文件夹里创建一个名为”动画“的文件夹方便管理，在”Assets“里的位置即为下一步创建动画默认位置，可提前进入此动画存放文件夹\n左方”层级“选择模型，在”动画“窗口点击”创建“，选择一个位置并命名动画名字后点击”保存“\n可以先将要打开物品关闭/隐藏(例如将创建的光源关闭)\n在”动画“窗口左方”预览“右边有个红色实心圈，点击即可开始录制\n此时再将要打开的物品打开/显示(例如将光源打开)\n然后再次点击红色实心圈关闭录制，然后关闭预览，将右方”检查器“中模型的”控制器“删除(点击后按”delete“) ，回到”Assets“，可以将自动生成的控制器删除\n四、将动画添加至FX层 # 1）打开模型FX层控制器 # 找到控制器所在位置点击即可在“动画器”窗口显示（可在左方点击模型名字后再在右方“VRC Avatar Descripor”找到FX层点击定位）\n2）创建参数和图层 # 在”动画器“窗口点击”“参数”，然后点击右方的“+”，选择“Bool”，然后重命名(例如灯光)\n然后点击“图层”，点击右方“+”，并重命名(例如灯光)，然后点击齿轮将权重改为1\n3）图层的制作 # 点击刚刚新建的图层，在右方空白处右击“创建状态-空”，然后将刚刚录制的动画拖入(例如灯光)\n此时在创建的空状态上右击“创建过度”然后鼠标移动到刚拖入的动画上左击\n点击这条线，在右方“检查器”将“有退出时间”取消勾选，然后在“Conditions”右下点击加号，选择刚刚创建的参数(例如灯光)和值(例如“true”)\n然后再创造一个从动画到空状态的过度，并且取消勾选“有退出时间”，在“Conditions”添加参数(例如灯光)和值(例如“false”)\n五、将开关添加至菜单 # 1）添加数值 # 找到数值文件并点击即可在右方检查器显示(可在左方点击模型名字后再在右方“VRC Avatar Descripor”找到“Parameters”点击定位)\n点击“Add”，在新加的一行输入“参数”名字与类型(例如灯光，Bool)，后方是默认值，最后为是否保存值(即切换模型再切换回来是否保留此物体状态，例如我勾选后，在游戏里打开了灯光没关，然后换了其他模型再换回来灯光还是开着的，未勾选则切换模型后会变回默认值)\n注意：此处参数名字要和刚刚在FX层控制器创建的参数名字相同，类型相同\n2）添加菜单 # 找到菜单文件并点击即可在右方检查器显示(可在左方点击模型名字后再在右方“VRC Avatar Descripor”找到“Menu”点击定位)\n点击“Add Control” ，输入名字，类型选择“Toggle”，Parameter选择刚刚创建的参数(例如灯光)\n六、简要概括-飞行 # 首先下载一个预制件： 飞行.prefab\n1）将物品放入模型子集\n2）录制物品开启动画\n3）动画添加至FX层\n4）添加至VRChat菜单和数值\n"},{"id":23,"href":"/upload/mmd_upload/","title":"MMD 模型上传","section":"上传","content":" 一、MMD 模型导入 Unity # 上篇文章讲述了 MMD 模型转换为 FBX，现在将 MMD 模型所有的文件都导入 Unity\n二、MMD 模型适配 # 1）材质 # 点击FBX文件，右方点击”Materials-位置-使用外部材质“，然后点击应用，等待亿会\n2）骨骼 # 依次点击”Rig-动画类型-人形“，点击应用，等待亿会\n然后点击”配置…“进入查看骨骼\n首先确定是不是T-pose，如果不是，右边划到最下方，点击”动作-强制T动作“，然后检查骨骼是否错误（一般有错误在”Head“）\n检查完毕后点击”Done“\n三、添加SDK描述文件 # 1）调整视角球 # ”VRC Avatar Descriptor“第一个为”View“，即我们要调整的视角球，点击”Edit“即可在Unity调整，大概放在额头前，然后回到脚本点击”Return“即可\n2）添加”Viseme“ # 如果未在Blend设置请忽视(即 MMD模型转换为FBX第三步未做)，请看 第四步或直接上传\n”VRC Avatar Descriptor“第二个为”LipSync“，”Mode“选择”Viseme Blend Shape“，左方将”Body“拖入”Face Mesh“会自动识别\n3）添加”Eye Look“ # ”VRC Avatar Descriptor“第三个为”Eye Look“，点击”Enable“，将左右眼睛骨骼拖入对应位置\n下方”Eyelids“的”Eyelid Type“选择”Blendshapes“，然后将”Body“拖入，即可自动识别\n四、添加动骨和碰撞 # 注意\nVRChat 官方指出 Dynamic bone 过段时间将会被完全移除，请学习或添加新动骨 PhysBones\n添加动骨和碰撞是需要反复尝试的，而且毕竟麻烦，如果不加的话在游戏里移动模型的衣服头发不会动\n1）动骨 # 在想要“动”的地方添加动骨，例如裙子，头发等，这里以裙子为例\n找到裙子所在的骨骼，点击后在右方点击“添加组件”，搜索“Dynamic bone”，添加\n然后将骨骼放进“Dynamic bone”的“Root”，调整四个参数\nDamping 阻力 Elasticity 弹性\n下面两个限制范围 Stiffness 刚度(比下面的小) Inert 惰性的\n以下参数仅供参考，具体请自行尝试最佳参数\n例：裙子参数 0.6 、 0.06 、 0.2 、0.4\n胸部参数 0.08 、 0.06\n头发参数 0.7 、 0.06 、 0.6 、0.85\n此处参数参考： VRchat模型之unity – 星空月零 – 博客园\n@莎莎 衣服0.9 0.03 0.1 0 @JIUJIU 特柔还不会穿模 0.7 0.06 0.9 0.9 @Ryuu-San 耳朵和尾巴 0.7 0.07 0.666 0.52 此处参数参考： VRCHAT模型上传常见问题汇总_Ryuu-San的博客-CSDN博客\n2）碰撞 # 动骨做完后在“游戏模式”下移动模型可以看到效果（穿模），这时可通过添加碰撞解决，例如腿部碰撞\n在想要添加碰撞的骨骼下方新建一个空物体（右击骨骼，点击“Create Empty”）\n点击这个空物体，在右方添加组件“Dynamic bone Collider”，调整大小和高度\n3）碰撞加入动骨 # 点击想放入碰撞并有动骨的骨骼(例如裙子)，将上一步创建的物体拖入右方动骨组件的碰撞器(例如腿部碰撞)即可（这样腿部的碰撞就可以和裙子动骨碰撞，从而使裙子撑起来）\n此时打开“播放模式”即可看到效果\n五、上传 # 上传参考 成品模型上传第四步\n关于”VRC Avatar Descriptor“其他部分将在后续文章描述\n"},{"id":24,"href":"/script/start/","title":"出场动画","section":"脚本","content":" 特效 # 可以寻找一些现成的特效使用\n特效处理 # 注意特效不能包含脚本(script)组件，如果有需要删除\n如果删除脚本后特效变成不想要的样子了那只能换一个了\n因为VRChat不允许上传脚本文件\n实装 # 将特效的循环(Looping)关闭放在模型上上传即可\n物品 # 可能有一些会转来转去的物品作为出场？当然，特效也适用此方法\n动画 # 将物体隐藏，然后录制一个物体的打开动画\nFX层 # 创建一个新图层，权重设为1\n拖入动画作为默认动画\n然后创建一个空状态，创建过渡，设置退出时间，时间长度自定(时间单位：上一状态动画长度，如为物体打开动画/空动画可当成以秒为单位)\n动画的时间 # 可以通过查看动画的帧数来确定，Unity默认为1秒60帧\n例如一动画一共240帧，则该动画为4秒\n动作 # 因切换到该模型时会执行追踪器重置？所以理论上应该不能做成出场动作动画，不过可以通过其他方式实现。注：个人理解\n动画 # 首先准备动作动画，然后录制一个模型隐藏的动画，即将模型的材质(Mesh)全部隐藏\nAction层 # 参数 # 创建一个Bool型参数，例如Start\n过渡 # 从WaitForActionOrAFK到Prepare Standing，条件为Start为true，取消勾选退出时间(Has Exit Time)\n动作动画 # 拖入动作动画，创建过渡Prepare Standing-动作动画-BlendOut Stand\n过渡条件 # Prepare Standing-动作动画：Start为true，无退出时间\n动作动画-BlendOut Stand：有退出时间，为1，无条件\n脚本 # 在状态BlendOut Stand添加VRC Avatar Parmeter Driver，将参数Start设为false\nFX层 # 参数 # 创建一个Bool型参数，名字与刚刚在Action层创建的一致，例如Start\n图层 # 新建图层，权重设为1\n以下Default与Hide状态对应的动画为录制的模型隐藏动画，Start为空状态\n图层结构：Entry-Default-Hide-Start\n过渡 # Default-Hide：无条件，有退出时间，为0.1\nHide-Start：无条件，有退出时间，为0.2\n脚本 # 在状态Hide添加VRC Avatar Parmeter Driver，将参数Start设为true\n解释 # Default-Hide的过渡时间是等待模型重设追踪器完成\nHide-Start的过渡时间是模型从站立到动作动画的起始动画需要时间，可自行调整时间大小\n"},{"id":25,"href":"/additional/set_mmd/","title":"固定世界 MMD","section":"附加","content":" 一、将MMD舞蹈转换为动画文件 # 1）下载VRC工具箱 # 下载地址： VRChatAvatarToolkit 发行版 – Gitee.com\n文件直链(Gitee)： VRC工具箱v1.2.5_by如梦.unitypackage\n作者B站： 如梦Nya的个人空间_哔哩哔哩_bilibili\n2）导入文件 # VRC工具箱 MMD动作文件(vmd文件) (可选)MMD的模型(pmx文件) 注：导入MMD的模型可防止一些动作变得奇怪\n3）转换 # 在顶部选择”VRC工具箱-MMD动作转换“\n将MMD动作文件和MMD模型(模型可不拖入)拖入相应位置\n然后点击”生成配置文件“后等待亿会即可\n4）检查动画是否正常 # 尽管是导入MMD来生成动画文件，但有些舞蹈动作转换后还是很怪\n先在左方”层级“中”CTRL+D“模型，隐藏原模型，将动画拖到新模型上(复制是防止发生错误)\n点击”播放“，角色就会开始跳舞\n5）调整动画方向 # 点击动画文件，在右方”跟变换旋转-依据“选择”原始“\n当然，对于固定于世界的模型是可选的，后续自身跳MMD更改方便观看\n二、导入并压缩音频文件 # 选择文件夹后直接拖入即可，压缩文件是由于VRChat限制模型加载” 200MB “\n点击音频文件，在右方选择压缩格式(一般默认的”Vorbis“即可)，选择质量(越低压缩率越高)，然后点击应用即可\n三、加入模型及音频舞蹈 # 1）加入模型和舞蹈 # 参考上篇文章，将模型放入对应”物品“的位置，文章： 固定世界物品\n直接将动画拖入想跳舞的模型名字上即可\n2）加入音频 # 在跳舞模型上创建一个空物体，然后添加组件”音频源“(英文: Audio Source)\n在”AudioClip“后方拖入音乐，”空间混合“调为”1“，”多普勒级别“调为”0“，”音量衰减“选”线性衰减“，”最大距离“可自由调节(例如20)\n3）音频邦骨 # 我制作一般会将音频邦骨在嘴部，邦骨参考： 物体绑骨\n4）调整位置 # 移动模型到想要的位置，例如前方1米，旋转180度\n四、录制动画 # 动画参考 固定世界物品的动画\n五、其他 # 如果是多人舞蹈可以添加多个模型，每个拖入不同动作，不过要注意位置，比如谁在左谁在右之类的\n"},{"id":26,"href":"/upload/sdk2_to_sdk3/","title":"SDK2 转为 SDK3","section":"上传","content":" 一、导入相关 # 不用导入SDK2，导入上传SDK3模型需要的东西即可\n二、去SDK2的描述 # 将模型放进场景后(拖入prefab文件或双击场景文件)，点击模型\n在右边将其余组件删除（一般最后俩个），仅保留“Transform”和“Animator”两个组件即可\n三、添加SDK3描述文件 # 1）调整视角球 # ”VRC Avatar Descriptor“第一个为”View“，即我们要调整的视角球，点击”Edit“即可在Unity调整，大概放在额头前，然后回到脚本点击”Return“即可\n2）添加”Viseme“ # ”VRC Avatar Descriptor“第二个为”LipSync“，点击“Auto Detect”即可自动识别\n如未能自动识别，一般将“Body”拖入相应位置即可 有些模型有“Body”和“Face”，请将“Mode”换成“Viseme Blend Shape”，然后将“Face”拖入“Face Mesh”即可（注意检查是否有错误）\n四、上传 # 上传参考 成品模型上传第四步\n关于”VRC Avatar Descriptor“其他部分将在后续文章描述\n"},{"id":27,"href":"/div/state_behaviors/","title":"State Behaviors","section":"Docs","content":" 添加 # 在“动画器-图层”点击一个状态，在“检查器”中点击“添加行为”即可看到VRC的脚本\nAnimator Layer Controller # 可以改变某一图层的权重(权重为1时正常播放)\n层权重将保持不变，直到某个其他状态再次运行此状态行为并将其重置\n名称 Purpose(目的) 可播放(Playable) 选择要改变的动画层 图层(Layer) 选择影响第几个图层(从0开始) ，第0层(即第一个)无法被改变(始终为1) Goal Weight 想要改变的权重 Blend Duration Define the time period (in seconds) that you want the blend to take. 0 means instant. Debug String 调试字符串，当此脚本运行时将此字符串输出至日志 Animator Locomotion Control # 在播放动画时禁用动作，位置被锁定\nPC下只可上下移动视角，VR可自由移动，但模型不会动\n此状态将一直保持，直到某个其他状态再次运行此状态行为并将其改变\n名称 Purpose(目的) Locomotion Control 如果选择“Disable”，运动将被禁用 Debug String 调试字符串，当此脚本运行时将此字符串输出至日志 Animator Temporary Pose Space # 调整视角球，移动至执行动画后额头位置\n视角球调整后将一直保持，直到某个其他状态再次运行此状态行为并将其改变\nPose Space “Enter”将更改，“Exit”将退出并重置为默认 Fixed Delay 调整“Delay Time(延迟时间)”为时间段或百分比 Delay Time 视角球将在设定值后调整 Debug String 调试字符串，当此脚本运行时将此字符串输出至日志 Animator Tracking Control # 以下内容为Google翻译+自己修改\n跟踪设置将一直保留，直到某个其他状态再次运行此状态行为并将其重置。\nAnimator Tracking Control 允许您启用或禁用 IK 或模拟化身身体各个不同部位的运动。将选项设置为“No Change”不会更改身体部位的当前值。“Tracking”会将其设置为跟随 IK 或模拟运动。“Animation”将强制身体部位遵从动画\n如果将所有 IK 跟踪点设置为Animation，您的动画将作为动画远程播放，而不是通过网络 IK 进行转换。对于各种类型的跟踪，这些“IK 跟踪点”是：\nPC：头、左手、右手 3pt 追踪：头部、左手、右手 6pt / FBT 追踪：头部、左手、右手、臀部、左脚、右脚 除了模拟的 Eyes and Eyelid 外，所有部分都是 IK 驱动的。嘴和下巴由 visemes 驱动。\n例如，将 Left Hand 和 Right Hand 设置为 Animation 将忽略 IK 定义的手（和手臂）的位置，而是使用任何当前活动状态的运动来定义手和手臂的位置。将它们设置回 Tracking 将改为使用 IK。\n将 Eyes \u0026amp; Eyelid 设置为 Animation 将禁用眼球运动和闭眼动作。将 Eyes \u0026amp; Eyelid 设置为 Tracking 将重新启用模拟的眼球运动和眨眼。\n将 Mouth and Jaw 设置为 Animation 将禁用发音嘴型(visemes)，但仍会发送发音嘴型参数(visemes)。设置 Mouth and Jaw 将重新启用发音嘴型(visemes)。\nAvatar Parameter Driver # 改变给定参数的值\n名字 Purpose(目的) Add Parameter (按钮) 添加一个要改变的参数 Name 选择要改变的参数 Change Type 如何改变？ Value 要改变的值 Playable Layer Control # 与Animator Layer Controller类似，不过是改变一个动画层的权重\n"},{"id":28,"href":"/additional/gesture/","title":"手势开关","section":"附加","content":"目标：开关打开时，右手握拳触发动画\n查表知：右手手势参数为“GestureRight”，类型为“Int”；握拳时，“GestureRight”值为“1”\n动画 # 首先录制一个动画，例如某物品打开\n控制器 # 在“动画器-参数”添加一个“Int”型参数，名字为“GestureRight”\n再创建一个“Bool”型参数作为开关，例“动画开关”\n新建图层，权重设为1，新建空状态命名为“默认”，再创建一个空状态命名(例动画开)，将动画拖入\n创建“默认-动画开”的过渡，条件为：“动画开关”为“true”；\n创建“动画开-动画”的过渡，条件为：“GestureRight”等于“1”\n创建“动画开-默认”的过渡，条件为：“动画开关”为“false”；\n创建“动画-动画开”的过渡，条件为：“GestureRight”不等于“1”\n菜单-数值 # 在“数值”文件添加“Bool”型“动画开关”\n在菜单中“Add Control”，重命名，“类型”为“Toggle”,”Parameter”为“动画开关”\n"},{"id":29,"href":"/div/cloth/","title":"Cloth","section":"Docs","content":"布料(Cloth)组件与带蒙皮的网格渲染器(Skinned Mesh Renderer)协同工作，从而提供基于物理的面料模拟解决方案。此组件是专为角色服装设计的，仅对蒙皮网格有效。如果向非蒙皮网格中添加Cloth组件，则 Unity 会删除非蒙皮网格并添加蒙皮网格。\n网格与骨骼权重处理 # 因为布料与动骨是不同的系统，为了共存需要做相应的处理\n大致为以下要求\n单层网格 确保衣服是单层的\n缝合网格 确保衣服是完整的\n分离干扰 衣服上的小配件可能会对布料模拟有所干扰\n四边形网格 如果衣服为三角形网格，可能不会有太好的模拟效果\n如何缝合网格？ # 在Blender中删除合并重叠点。顶部菜单网格-清理-按距离合并左下角按间距合并，通过修改增大合并间距的数值让两个距离相邻的两个点合并。快捷键：M\n添加布料 # 在Inspector窗口中单击Add Component按钮，然后选择 Physics-Cloth\nEdit cloth constraints(编辑约束) # 您可以将约束应用于布料的特定顶点，以增加或减少这些顶点的移动自由度。\nCloth Constraints # 属性 选项 功能 Visualization 选择要显示的约束类型和粒子。 Max Distance 仅显示布料粒子的 Max Distance 值。 Surface Penetration 仅显示布料粒子的 Surface Penetration 值。 Manipulate Backfaces 启用此选项可以可视化和操控可能隐藏在布料当前朝向部分后面的粒子。 [ 色谱 ] 根据当前在整块布料中应用的最小值和最大值，为上述选定的约束类型提供粒子颜色和约束值之间的对应关系。黑色始终表示粒子没有约束。 Constraint Size 代表布料粒子的球体的显示大小。在方便时可以调整此值以便简化约束版本。这个属性对约束本身没有任何影响。 约束类型与颜色 # 约束类型 描述 Max Distance 布料可以从顶点位置行进的最大距离 Surface Penetration 布料粒子可穿透网格的深度 根据在Visualization所选类型，粒子的颜色表示该粒子的约束在布料内的相对值\n约束版本模式 # 一共可以使用三种不同模式来编辑布料的约束值\n1）Select # 将固定约束值应用于已选择的粒子组\n使用鼠标框选后，启用要应用于选定项的约束类型然后设定一个值即可\n2）Paint # 通过用画笔绘制布料粒子来施加固定的约束值\n根据需要调整Brush Radius，启用要应用的约束类型并设置一个绘制值后用画笔在粒子上绘制约束\n3）Gradient # 将约束值从左到右线性渐变应用于预先选择的粒子组\n需先确保在场景视图中开启2D视图\n使用鼠标框选后，设置范围，然后选择要应用的约束类型\nEdit cloth self/inter-collision(编辑自碰撞与互碰撞) # 自碰撞：防止布料穿透自身 互碰撞：允许布料粒子相互碰撞 Cloth Self-Collision and Inter-Collision # 属性 选项 功能 Visualization 选择要显示的约束类型和粒子。 Self-Collision 自碰撞 Inter-Collision 互碰撞 Manipulate Backfaces 启用此选项可以可视化和操控可能隐藏在布料当前朝向部分后面的粒子。 颜色 # 颜色 描述 黑色 未使用的粒子 蓝色 当前选中粒子 绿色 已应用碰撞粒子 应用 # 选择Select，使用鼠标框选后勾选Self-Collision and Inter-Collision即可\nSelf-Collison # 在应用自碰撞与互碰撞后检查器会多出此选项\n此时场景中粒子，可能会消失，将检查器中Self-Collision Distance调大即可看到\n属性 功能 Distance 每个粒子的包裹球体的直径。Unity 确保这些球体在模拟过程中不会重叠。Distance 属性的值应小于配置中的两个粒子之间的最小距离。如果距离较大，则自碰撞可能违反某些距离约束并导致抖动。 Stiffness 粒子之间的分离冲力的强度。此值由布料解算器进行计算，应足以保持粒子分离。 Paint与Erase # 调整好Brush Radius后在场景中滑动以添加或删除用于碰撞的粒子\n互碰撞 # 指定粒子与自碰撞相同，不过设置在Edit-Project Setting-Physics中勾选Cloth Inter-Collision，然后设置Distance与Stiffness(功能与自碰撞的相同)\n注意 # 自碰撞和互碰撞可能需要大量的总模拟时间。请考虑缩小碰撞距离并使用自碰撞索引来减少彼此碰撞的粒子数\n自碰撞使用顶点，而不是三角形，因此对于三角形远大于布料厚度的网格，不要指望碰撞能够完美运行\n检查器属性 # 属性 功能 Stretching Stiffness 布料的伸展刚性 Bending Stiffness 布料的弯曲刚性 Use Tethers 施加约束以帮助防止移动的布料粒子离开固定粒子的距离太远。此属性有助于减少过度拉伸。 Use Gravity 重力是否影响布料的模拟 Damping 布料运动时的阻尼 External Acceleration 施加在布料上的恒定外部加速度。在布料上固定的外部加速度，主要用于模拟风的效果，可设定XYZ方向 Random Acceleration 施加在布料上的随机外部加速度。在布料上随机的外部加速度，让布料产生不规则的摆动 World Velocity Scale 角色多大程度的世界空间移动会影响布料顶点。 World Acceleration Scale 角色多大的世界空间加速度会影响布料顶点。 Friction 布料与角色碰撞时的摩擦力。设定布料的摩擦系数 Collision Mass Scale 碰撞粒子的质量增加量。 Use Continuous Collision 启用连续碰撞来提高碰撞稳定性。 Use Virtual Particles 每个三角形添加一个虚拟粒子，从而提高碰撞稳定性。 Solver Frequency 解算器每秒迭代次数。 Sleep Threshold 布料的睡眠阈值。 Capsule Colliders 应与此布料实例碰撞的胶囊碰撞体的数组。 Sphere Colliders 应与此布料实例碰撞的球形碰撞体的数组。 virtual Particle Weights 虚拟粒子权重 参考数据\nStretching Stiffness：0.8\nBending Stiffness：0.2\nDamping：0.2\nWorld Velocity Scale：0（若想移动时晃动，改为0.2）\nWorld Acceleration Scale：0（若想移动时晃动，改为0.2）\nFriction：0\nCollision Mass Scale：0\n数据来源： https://www.bilibili.com/video/BV1ob411e7Q8\n碰撞 # 布料仅可以与胶囊碰撞体或球形碰撞体相互作用，其中两个球形碰撞体可以相连形成锥体碰撞。\n碰撞体记得勾选is trigger(是触发器)，不然游戏里移动或者跳跃会产生一股脚踩脚的感觉而且还会转圈\n胶囊碰撞体 # 胶囊碰撞体由两个半球与一个圆柱体连接在一起组成\n添加 # 在相应骨骼创建空物体，在检查器窗口中单击Add Component按钮，然后选择 Physics-Capsule Collider\n属性 # 属性 功能 Edit Collider 选中即可在场景中可视化编辑大小 Is Trigger 如果启用此属性，则该碰撞体将用于触发事件，并被物理引擎忽略 Material 引用物理材质，可确定该碰撞体与其他对象的交互方式 Center 碰撞体在对象局部空间中的位置 Radius 碰撞体的局部宽度的半径 Height 碰撞体的总高度 Direction 胶囊体在对象局部空间中纵向方向的轴。 结构 # 添加到布料 # 直接将碰撞所在物体拖到Cloth(布料)的Capsule Colliders(胶囊碰撞器)处即可\n球形碰撞体与锥体 # 球形碰撞体是一种基本的球体形状原始碰撞体\n添加 # 在相应骨骼创建空物体，在检查器窗口中单击Add Component按钮，然后选择 Physics-Sphere Collider\n属性 # 属性 功能 Edit Collider 选中即可在场景中可视化编辑大小 Is Trigger 如果启用此属性，则该碰撞体将用于触发事件，并被物理引擎忽略 Material 引用物理材质，可确定该碰撞体与其他对象的交互方式 Center 碰撞体在对象局部空间中的位置 Radius 碰撞体半径的大小 添加到布料 # 在Cloth(布料)的Sphere Colliders(球体碰撞器)将Size调整为非零值，每个元素可以放两个球体碰撞\n如果只放入一个，则为球体碰撞\n如果放入两个，那么两个球体碰撞将自动相连为锥体碰撞\n"},{"id":30,"href":"/div/particle_system/","title":"Particle System","section":"Docs","content":" 文章过长，可能有所疏忽-最后更新：2022.08.11\n前言 # 粒子系统组件具有许多属性，为方便起见，检查器将它们组织成多个称为“模块”的可折叠部分\n要展开和折叠模块，请单击显示模块名称的栏。使用左侧的复选框可启用或禁用该模块中属性的功能\nOpen Editor(打开编辑器)按钮在单独的 Editor 窗口中显示选项，可让您一次性编辑多个系统\n在本文中表格属性处黑体为一级属性，斜体为属性选项，无字体为二级属性\n另：粒子系统属性设置一般单位为秒\n创建 # 在层级右击，选择效果-粒子系统\n场景面板 # Scene(场景)视图中的Particle Effect(粒子效果)面板包含一些关于预览粒子系统的附加选项\n属性 功能 Simulate Layers(模拟层) 预览未选定的粒子系统。默认情况下，只有选定的粒子系统才能在场景视图中播放。但是，将Simulate Layers设置为Nothing以外的任何其他选项时，与Layer Mask匹配的效果会自动播放，而无需您选择它们。这对于预览环境效果特别有用 Resimulate(重新模拟) 启用此属性后，粒子系统会立即将属性更改应用于已生成的粒子。禁用此属性后，粒子系统会按原样保留现有粒子，仅将属性更改应用于新粒子 Show Bounds(显示边界) 启用此属性后，Unity 显示选定粒子系统的包围体积。这些边界可确定粒子系统当前是否在屏幕上 Show Only Selected(仅显示已选择) 启用此属性后，Unity 隐藏所有非选定粒子系统，便于专注产生单一效果 Particle System(粒子系统)主模块 # Particle System模块包含影响整个系统的全局属性。大多数这些属性用于控制新创建的粒子的初始状态。要展开和折叠主模块，请单击Inspector(检查器)窗口中的Particle System栏\n属性 功能 Duration(持续时间) 粒子系统运行的时间长度，或者说周期，不同于粒子本身的生命周期 Looping(循环播放) 如果启用此属性，粒子系统将在其持续时间结束时再次启动并继续重复该循环 Prewarm(预热) 如果启用此属性，系统将初始化，就像已经完成一个完整周期一样。仅在Looping勾选时可用 Start Delay(启动延迟) 启用此属性后，粒子系统开始发射前将延迟一段时间（以秒为单位）。若Prewarm勾选则不可用 Start Lifetime(初始生命周期) 粒子的初始生命周期。即粒子存在的时间 Start Speed(初始速度) 粒子发射时的初始速度 3D Start Size(3D初始尺寸) 勾选则下一项Start Size可从X(宽度)Y(高度)Z(深度)轴控制。Z(深度)仅适用于3D网格粒子 Start Size(初始尺寸) 每个粒子的初始大小。即粒子发射时大小 3D Start Rotation(3D初始旋转) 勾选则下一项Start Rotation可从XYZ轴控制 Start Rotation(初始旋转) 每个粒子的初始旋转角度。即粒子发射时旋转的角度 Flip Rotation(翻转旋转) 使一些粒子以相反的方向旋转。只有0和1表示关闭与开启 Start Color(初始颜色) 每个粒子的初始颜色 Gravity Modifier(重力修改器) 粒子受重力影响程度。缩放Physics窗口(Edit-Project Settings-Physics)中设置的重力值。值为零会关闭重力 Simulation Space(模拟空间) 粒子模拟空间。粒子跟随哪个物品一起移动 Local(局部) 父对象的局部空间中（因此与父对象一起移动） World(世界) 在世界空间中独立移动，即粒子发射后不随物体移动 Custom(自定义) 相对于自定义对象（与您选择的自定义对象一起移动） Simulation Speed(模拟速度) 调整整个系统更新的速度，或者说播放速度 Delta Time(时间查) 在Scaled和Unscaled之间进行选择。此属性对于出现在暂停菜单上的粒子系统非常有用 Scaled 使用Time(Edit-Project Settings-Time)窗口中的Time Scale(时间尺度)值 Unscaled 忽略该值 Scaling Mode(缩放模式) 选择如何使用变换中的缩放，或者说粒子跟随什么放大缩小 Hierarch(层级) 相对于Local，粒子所在父级也会影响粒子大小 Local(局部) 仅应用粒子系统变换缩放，忽略任何父级，即仅跟随粒子所在物品放大缩小 Shape(形状) 将缩放应用于粒子起始位置，但不影响粒子大小 Play on Awake(唤醒时播放) 粒子系统被创造出来时，会自动产生粒子 Emitter Velocity(发射器速度) 选择粒子系统如何计算Inherit Velocity和Emission模块使用的速度 Transform 通过跟踪变换组件的移动情况来计算速度 Rigidbody 系统可使用刚体组件（如果存在）来计算速度 Max Particles(最大粒子) 系统中同时允许的最多粒子数。如果达到限制，则移除一些粒子 Auto Random Seed(自动随机种子) 如果启用此属性，则每次播放时粒子系统看起来都会不同。设置为false时，每次播放时系统都完全相同 Random Seed(随机种子) 禁用自动随机种子时，此值用于创建唯一的可重复效果 Stop Action(停止行动) 当属于系统的所有粒子都已完成时，可使系统执行某种操作。当一个系统的所有粒子都已死亡，并且系统存活时间已超过Duration设定的值时，判定该系统已停止。对于循环系统，只有在通过脚本停止系统时才会发生这种情况 none(无) 无 Disable(禁用) 禁用游戏对象 Destroy(销毁) 销毁游戏对象 Callback(回调) 将OnParticleSystemStopped回调发送给附加到游戏对象的任何脚本 Culling Mode(剔除模式) 选择粒子在屏幕外时是否暂停粒子系统模拟。在屏幕外时进行剔除具有最高效率，但您可能希望继续进行非一次性 (off-one) 效果的模拟 Automatic(自动) 循环系统使用Pause，而所有其他系统使用Always Simulate Pause And Catch-up(暂停和追赶) 统在屏幕外时停止模拟。当重新进入视图时，模拟会执行一大步以到达在不暂停的情况下可实现的程度。在复杂系统中，此选项可能会导致性能尖峰 Pause(暂停) 系统在屏幕外时停止模拟 Always Simulate(始终模拟) 无论是否在屏幕上，系统始终处理每个帧的模拟。这对于烟花等一次性效果（在模拟过程中这些效果很明显）非常有用 Ring Buffer Mode(环状缓冲模式) 保持粒子存活直到它们达到Max Particles计数，此时新粒子会取代最早的粒子，而不是在它们的寿命终结时才删除粒子 Disabled(已禁用) 禁用Ring Buffer Mode，以便系统在粒子生命周期终结时删除粒子 Pause Until Replaced(暂停直到替换) 在粒子生命周期结束时暂停旧粒子，直至达到Max Particle限制，此时系统会进行粒子再循环，因此旧粒子会重新显示为新粒子 Loop Until Replaced(循环直到替换) 在粒子生命周期结束时，粒子将倒回到其生命周期的指定比例，直至达到Max Particle限制，此时系统会进行粒子再循环，因此旧粒子会重新显示为新粒子 右方下拉菜单 # 许多属性的右方有下拉菜单，可进行生命周期内调整\n数值 # 属性 功能 Constant(常量) 粒子属性一直保持此数值，以秒为单位 Curve(曲线) 粒子属性可设定为在粒子的生命周期内变化。检查器底部会出现一个曲线编辑器，可用于控制粒子在整个生命周期内的属性变化情况。如果勾选了分离轴相关复选框，则可为每个 X、Y 和 Z 轴赋予曲线属性值 Random Between Two Constants(两常数间随机) 设置两个数值，允许粒子属性在它们之间随机取值 Random Between Two Curves(两曲线间随机) 粒子属性可设定为在粒子的生命周期（由曲线指定）内变化。在此模式下，两条曲线均为可编辑状态，每个粒子将在您定义的这两条曲线的范围之间选择一条随机曲线 颜色 # 属性 描述 颜色 设置一个颜色，粒子属性一直保持此颜色 渐变 粒子属性可设定为在粒子的生命周期内变化 双色间随机 设置两个颜色，允许粒子属性在它们之间随机取颜色值 双渐变间随机 粒子属性可设定为在粒子的生命周期（由曲线指定）内变化。在此模式下，两条渐变均为可编辑状态，每个粒子将在您定义的这两条渐变的范围之间选择一条随机渐变 随机颜色 在渐变中随机选取一个颜色 关于渐变 # 上方为透明度，下方为颜色，单击增加点，每行可添加点上限为8\n渐变条的左侧点表示粒子寿命的开始，而渐变条的右侧表示粒子寿命的结束\nEmission(发射) # 此模块中的属性会影响粒子系统发射的速率和时间\n属性 功能 Rate over Time(随单位时间产生的粒子数) 每个时间单位发射的粒子数 Rate over Distance(随移动距离产生的粒子数) 每个移动距离单位发射的粒子数 Bursts(爆发) 爆发是指生成粒子的事件。通过这些设置可允许在指定时间发射粒子 Time(时间) 设置发射爆发粒子的时间（粒子系统开始播放后的秒数） Count(数量) 设置可能发射的粒子数的值 Cycles(周期) 设置播放爆发次数的值\n右方下拉菜单可选择无穷大或数量 Interval(间隔) 设置触发每个爆发周期的间隔时间（以秒为单位）的值 Probability(概率) 控制每个爆发事件生成粒子的可能性，较高的值使系统产生更多的粒子，而值为1将保证系统产生粒子 Shape(形状) # 此模块用于定义可发射粒子的体积或表面以及起始速度的方向\nSphere 类 Sphere 球体、Hemisphere 半球\n属性 功能 Shape(形状) 发射体积的形状 Sphere(球体) 在所有方向均匀发射粒子 Hemisphere(半球) 在平面其中一面的所有方向均匀发射粒子 Radius(半径) 形状的圆形半径 Radius Thickness(半径厚度) 发射粒子的体积比例。值为 0 表示从形状的外表面发射粒子。值为 1 表示从整个体积发射粒子。介于两者之间的值将使用体积的一定比例 Arc(弧度) 形成发射器形状的整圆的角部 Mode 定义 Unity 如何在形状的弧形周围生成粒子 Random(随机) 在弧形周围随机生成粒子 Loop(循环) 在形状的弧形周围依序生成粒子，并在每个周期结束时循环回到起点 Ping-Pong(乒乓) 与Loop基本相同，不同之处在于每个连续循环的发生方向与上一个循环相反 Burst Spread(突发扩张) 在形状周围均匀分布粒子生成位置。此模式可提供均匀的粒子扩散，不同于默认的随机化行为，默认情况下的粒子可能不均匀地聚集在一起。最适合与爆发发射一起使用 Spread 弧形周围可产生粒子的离散间隔。例如，值为 0 表示允许在弧形周围的任何位置生成粒子，值为 0.1 表示仅在形状周围以 10% 的间隔生成粒子 Speed 发射位置围绕弧形移动的速度。仅当Mode为Loop和Ping-Pong时可用。使用值字段旁边的小黑色下拉菜单将此属性设置为Constant(常量)可使值始终保持不变，而设置为Curve(曲线)可使值随时间变化 Texture(纹理) 用于为粒子着色和丢弃粒子的纹理 Position(位置) 将一个偏移应用于生成粒子的发射器形状 Rotation(旋转) 旋转生成粒子的发射器形状 Scale(缩放) 更改生成粒子的发射器形状的大小 Align to Direction(方向对齐) 根据粒子的初始行进方向定向粒子。如果想要模拟大块的汽车油漆在碰撞过程中飞出车身，此设置将非常有用。如果对该方向不太满意，也可通过在主模块中应用Start Rotation值来覆盖该设置 Randomize Direction(随机化方向) 将粒子方向朝随机方向混合。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向完全随机 Spherize Direction(球面化方向) 将粒子方向朝球面方向混合，从它们的变换中心向外行进。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向从中心向外（与 Shape 设置为 Sphere 时的行为相同） Randomize Position(随机化位置) 以随机量移动粒子，直至达到指定值。此属性设置为 0 时，此设置不起作用。任何其他值都会对粒子的生成位置应用一些随机性 Cone Cone(锥体)\n属性 功能 Shape(形状) 发射体积的形状 Cone(锥体) 从锥体的底部或主体发射粒子。根据粒子与锥体中心线的距离按比例发射粒子 Angle(角度) 锥体在其顶点处的角度。角度为 0 时产生圆柱体，角度为 90 度时产生圆盘 Radius(半径) 形状的圆形半径 Radius Thickness(半径厚度) 发射粒子的体积比例。值为 0 表示从形状的外表面发射粒子。值为 1 表示从整个体积发射粒子。介于两者之间的值将使用体积的一定比例 Arc(弧度) 形成发射器形状的整圆的角部 Mode 定义 Unity 如何在形状的弧形周围生成粒子 Random(随机) 在弧形周围随机生成粒子 Loop(循环) 在形状的弧形周围依序生成粒子，并在每个周期结束时循环回到起点 Ping-Pong(乒乓) 与Loop基本相同，不同之处在于每个连续循环的发生方向与上一个循环相反 Burst Spread(突发扩张) 在形状周围均匀分布粒子生成位置。此模式可提供均匀的粒子扩散，不同于默认的随机化行为，默认情况下的粒子可能不均匀地聚集在一起。最适合与爆发发射一起使用 Spread 弧形周围可产生粒子的离散间隔。例如，值为 0 表示允许在弧形周围的任何位置生成粒子，值为 0.1 表示仅在形状周围以 10% 的间隔生成粒子 Speed 发射位置围绕弧形移动的速度。仅当Mode为Loop和Ping-Pong时可用。使用值字段旁边的小黑色下拉菜单将此属性设置为Constant(常量)可使值始终保持不变，而设置为Curve(曲线)可使值随时间变化 Length(长度) 锥体的长度。仅当Emit from:属性设置为Volume时，此选项才适用 Emit from:(发射于：) 锥体发射粒子的部分：Base(基础) 或 Volume(音量) Texture(纹理) 用于为粒子着色和丢弃粒子的纹理 Position(位置) 将一个偏移应用于生成粒子的发射器形状 Rotation(旋转) 旋转生成粒子的发射器形状 Scale(缩放) 更改生成粒子的发射器形状的大小 Align to Direction(方向对齐) 根据粒子的初始行进方向定向粒子。如果想要模拟大块的汽车油漆在碰撞过程中飞出车身，此设置将非常有用。如果对该方向不太满意，也可通过在主模块中应用 Start Rotation 值来覆盖该设置 Randomize Direction(随机化方向) 将粒子方向朝随机方向混合。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向完全随机 Spherize Direction(球面化方向) 将粒子方向朝球面方向混合，从它们的变换中心向外行进。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向从中心向外（与 Shape 设置为 Sphere 时的行为相同） Randomize Position(随机化位置) 以随机量移动粒子，直至达到指定值。此属性设置为 0 时，此设置不起作用。任何其他值都会对粒子的生成位置应用一些随机性 Donut Donut(甜甜圈)\n属性 功能 Shape(形状) 发射体积的形状 Donut(甜甜圈) 从环面发射粒子。粒子从环面的环向外移动 Radius(半径) 主圆环的半径 Donus Radius(甜甜圈半径) 外圆环的粗度 Radius Thickness(半径厚度) 发射粒子的体积比例。值为 0 表示从形状的外表面发射粒子。值为 1 表示从整个体积发射粒子。介于两者之间的值将使用体积的一定比例 Arc(弧度) 形成发射器形状的整圆的角部 Mode 定义 Unity 如何在形状的弧形周围生成粒子 Random(随机) 在弧形周围随机生成粒子 Loop(循环) 在形状的弧形周围依序生成粒子，并在每个周期结束时循环回到起点 Ping-Pong(乒乓) 与Loop基本相同，不同之处在于每个连续循环的发生方向与上一个循环相反 Burst Spread(突发扩张) 在形状周围均匀分布粒子生成位置。此模式可提供均匀的粒子扩散，不同于默认的随机化行为，默认情况下的粒子可能不均匀地聚集在一起。最适合与爆发发射一起使用 Spread 弧形周围可产生粒子的离散间隔。例如，值为 0 表示允许在弧形周围的任何位置生成粒子，值为 0.1 表示仅在形状周围以 10% 的间隔生成粒子 Speed 发射位置围绕弧形移动的速度。仅当Mode为Loop和Ping-Pong时可用。使用值字段旁边的小黑色下拉菜单将此属性设置为Constant(常量)可使值始终保持不变，而设置为Curve(曲线)可使值随时间变化 Texture(纹理) 用于为粒子着色和丢弃粒子的纹理 Position(位置) 将一个偏移应用于生成粒子的发射器形状 Rotation(旋转) 旋转生成粒子的发射器形状 Scale(缩放) 更改生成粒子的发射器形状的大小 Align to Direction(方向对齐) 根据粒子的初始行进方向定向粒子。如果想要模拟大块的汽车油漆在碰撞过程中飞出车身，此设置将非常有用。如果对该方向不太满意，也可通过在主模块中应用 Start Rotation 值来覆盖该设置 Randomize Direction(随机化方向) 将粒子方向朝随机方向混合。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向完全随机 Spherize Direction(球面化方向) 将粒子方向朝球面方向混合，从它们的变换中心向外行进。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向从中心向外（与 Shape 设置为 Sphere 时的行为相同） Randomize Position(随机化位置) 以随机量移动粒子，直至达到指定值。此属性设置为 0 时，此设置不起作用。任何其他值都会对粒子的生成位置应用一些随机性 Box Box(盒)\n属性 功能 Shape(形状) 发射体积的形状 Box(盒) 从盒体形状的边、表面或主体发射粒子。粒子在发射器对象的前向 (Z) 方向上移动 Emit from:(发射于：) 选择盒体发射粒子的部分。Volume(音量)，Shell(壳)和Edge(边缘) Texture(纹理) 用于为粒子着色和丢弃粒子的纹理 Position(位置) 将一个偏移应用于生成粒子的发射器形状 Rotation(旋转) 旋转生成粒子的发射器形状 Scale(缩放) 更改生成粒子的发射器形状的大小 Align to Direction(方向对齐) 根据粒子的初始行进方向定向粒子。如果想要模拟大块的汽车油漆在碰撞过程中飞出车身，此设置将非常有用。如果对该方向不太满意，也可通过在主模块中应用 Start Rotation 值来覆盖该设置 Randomize Direction(随机化方向) 将粒子方向朝随机方向混合。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向完全随机 Spherize Direction(球面化方向) 将粒子方向朝球面方向混合，从它们的变换中心向外行进。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向从中心向外（与 Shape 设置为 Sphere 时的行为相同） Randomize Position(随机化位置) 以随机量移动粒子，直至达到指定值。此属性设置为 0 时，此设置不起作用。任何其他值都会对粒子的生成位置应用一些随机性 Mesh 类 Mesh(网格)、MeshRenderer(网格渲染器)、SkinnedMeshRenderer(蒙皮网格渲染器)\n属性 功能 Shape(形状) 发射体积的形状 Mesh(网格) 从检查器中提供的任意网格形状发射粒子 MeshRenderer(网格渲染器) 从引用的游戏对象网格渲染器 (Mesh Renderer) 发射粒子 SkinnedMeshRenderer(蒙皮网格渲染器) 从引用的游戏对象带蒙皮的网格渲染器 (Skinned Mesh Renderer) 发射粒子 Type(类型) 指定从何处发射粒子 Vertex(顶点) 从顶点发射粒子 Edge(边缘) 从边发射粒子 Triangle(三角形) 从三角形发射粒子 Mode 如何为每个新粒子选择网格上的位置 Random(随机) 对于要选择随机位置的粒子 Loop(循环) 对于要从网格中下一个顶点发射的每个新粒子 Ping-Pong(乒乓) 类似于 Loop 模式，但会在每个循环后沿网格顶点交替方向 Mesh(网格) 提供发射器形状的网格 Single Material(单一材料) 指定是否从特定子网格（由材质索引号标识）发射粒子。如果启用此属性，则会显示一个数字字段，您可以使用该字段指定材质索引号 Use Mesh Colors(使用网格颜色) 使用网格顶点颜色调整粒子颜色，或者，如果顶点颜色不存在，则使用材质中的着色器颜色属性Color或TintColor Normal Offset(法线偏移) 在距离网格表面多远处发射粒子（在表面法线的方向上） Texture(纹理) 用于为粒子着色和丢弃粒子的纹理 Position(位置) 将一个偏移应用于生成粒子的发射器形状 Rotation(旋转) 旋转生成粒子的发射器形状 Scale(缩放) 更改生成粒子的发射器形状的大小 Align to Direction(方向对齐) 根据粒子的初始行进方向定向粒子。如果想要模拟大块的汽车油漆在碰撞过程中飞出车身，此设置将非常有用。如果对该方向不太满意，也可通过在主模块中应用 Start Rotation 值来覆盖该设置 Randomize Direction(随机化方向) 将粒子方向朝随机方向混合。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向完全随机 Spherize Direction(球面化方向) 将粒子方向朝球面方向混合，从它们的变换中心向外行进。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向从中心向外（与 Shape 设置为 Sphere 时的行为相同） Randomize Position(随机化位置) 以随机量移动粒子，直至达到指定值。此属性设置为 0 时，此设置不起作用。任何其他值都会对粒子的生成位置应用一些随机性 注意：网格必须设置为read/write enabled才能在粒子系统上工作。如果在Editor中分配网格，Unity 会为您进行此处理。但如果要在运行时分配不同的网格，则需要选中网格Import Settings中的Read/Write Enabled设置\nMode属性允许粒子系统以可预测的顺序在网格表面上发射粒子。从顶点发射时，此属性允许从网格顶点数组中的下一个顶点发射每个新粒子。从边缘发射时，粒子系统可以沿着网格的三角形/线条的边缘平滑地发射粒子\nSprite 类 Sprite、Sprite Renderer\n属性 功能 Shape(形状) 发射体积的形状 Sprite 从检查器中提供的Sprite形状发射粒子 Sprite Renderer 从引用的游戏对象Sprite Renderer发射粒子 Type(类型) 指定从何处发射粒子 Vertex(顶点) 从顶点发射粒子 Edge(边缘) 从边发射粒子 Triangle(三角形) 从三角形发射粒子 Sprite 用于定义粒子发射器形状的Sprite Normal Offset(法线偏移) 在距离Sprite表面多远处发射粒子（在表面法线的方向上） Texture(纹理) 用于为粒子着色和丢弃粒子的纹理 Position(位置) 将一个偏移应用于生成粒子的发射器形状 Rotation(旋转) 旋转生成粒子的发射器形状 Scale(缩放) 更改生成粒子的发射器形状的大小 Align to Direction(方向对齐) 根据粒子的初始行进方向定向粒子。如果想要模拟大块的汽车油漆在碰撞过程中飞出车身，此设置将非常有用。如果对该方向不太满意，也可通过在主模块中应用 Start Rotation 值来覆盖该设置 Randomize Direction(随机化方向) 将粒子方向朝随机方向混合。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向完全随机 Spherize Direction(球面化方向) 将粒子方向朝球面方向混合，从它们的变换中心向外行进。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向从中心向外（与 Shape 设置为 Sphere 时的行为相同） Randomize Position(随机化位置) 以随机量移动粒子，直至达到指定值。此属性设置为 0 时，此设置不起作用。任何其他值都会对粒子的生成位置应用一些随机性 Circle Circle(圆形)\n属性 功能 Shape(形状) 发射体积的形状 Circle(圆形) 从圆形的中心或边缘均匀发射粒子。粒子仅在圆形的平面内移动 Radius(半径) 形状的圆形半径 Radius Thickness(半径厚度) 发射粒子的体积比例。值为 0 表示从形状的外表面发射粒子。值为 1 表示从整个体积发射粒子。介于两者之间的值将使用体积的一定比例 Arc(弧度) 形成发射器形状的整圆的角部 Mode 定义 Unity 如何在形状的弧形周围生成粒子 Random(随机) 在弧形周围随机生成粒子 Loop(循环) 在形状的弧形周围依序生成粒子，并在每个周期结束时循环回到起点 Ping-Pong(乒乓) 与Loop基本相同，不同之处在于每个连续循环的发生方向与上一个循环相反 Burst Spread(突发扩张) 在形状周围均匀分布粒子生成位置。此模式可提供均匀的粒子扩散，不同于默认的随机化行为，默认情况下的粒子可能不均匀地聚集在一起。最适合与爆发发射一起使用 Spread 弧形周围可产生粒子的离散间隔。例如，值为 0 表示允许在弧形周围的任何位置生成粒子，值为 0.1 表示仅在形状周围以 10% 的间隔生成粒子 Speed 发射位置围绕弧形移动的速度。仅当Mode为Loop和Ping-Pong时可用。使用值字段旁边的小黑色下拉菜单将此属性设置为Constant(常量)可使值始终保持不变，而设置为Curve(曲线)可使值随时间变化 Texture(纹理) 用于为粒子着色和丢弃粒子的纹理 Position(位置) 将一个偏移应用于生成粒子的发射器形状 Rotation(旋转) 旋转生成粒子的发射器形状 Scale(缩放) 更改生成粒子的发射器形状的大小 Align to Direction(方向对齐) 根据粒子的初始行进方向定向粒子。如果想要模拟大块的汽车油漆在碰撞过程中飞出车身，此设置将非常有用。如果对该方向不太满意，也可通过在主模块中应用 Start Rotation 值来覆盖该设置 Randomize Direction(随机化方向) 将粒子方向朝随机方向混合。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向完全随机 Spherize Direction(球面化方向) 将粒子方向朝球面方向混合，从它们的变换中心向外行进。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向从中心向外（与 Shape 设置为 Sphere 时的行为相同） Randomize Position(随机化位置) 以随机量移动粒子，直至达到指定值。此属性设置为 0 时，此设置不起作用。任何其他值都会对粒子的生成位置应用一些随机性 Edge Edge(边缘)\n属性 功能 Shape(形状) 发射体积的形状 Edge(边缘) 从线段发射粒子。粒子在发射器对象的向上 (Y) 方向上移动 Radius 定义边的长度 Mode 定义 Unity 如何沿着形状的半径生成粒子 Random(随机) 沿着半径随机生成粒子 Loop(循环) 沿着形状的半径依序生成粒子，并在每个周期结束时循环回到起点 Ping-Pong(乒乓) 与Loop基本相同，不同之处在于每个连续循环的发生方向与上一个循环相反 Burst Spread(突发扩张) 沿着半径均匀分布粒子生成位置。此模式可提供均匀的粒子扩散，不同于默认的随机化行为，默认情况下的粒子可能不均匀地聚集在一起。最适合与爆发发射一起使用 Spread 沿着半径可产生粒子的离散间隔。例如，值为 0 表示允许沿着半径的任何位置生成粒子，值为 0.1 表示仅沿着半径以 10% 的间隔生成粒子 Speed 发射位置沿着半径移动的速度。仅当Mode为Loop和Ping-Pong时可用。使用值字段旁边的小黑色下拉菜单将此属性设置为Constant(常量)可使值始终保持不变，而设置为Curve(曲线)可使值随时间变化 Texture(纹理) 用于为粒子着色和丢弃粒子的纹理 Position(位置) 将一个偏移应用于生成粒子的发射器形状 Rotation(旋转) 旋转生成粒子的发射器形状 Scale(缩放) 更改生成粒子的发射器形状的大小 Align to Direction(方向对齐) 根据粒子的初始行进方向定向粒子。如果想要模拟大块的汽车油漆在碰撞过程中飞出车身，此设置将非常有用。如果对该方向不太满意，也可通过在主模块中应用 Start Rotation 值来覆盖该设置 Randomize Direction(随机化方向) 将粒子方向朝随机方向混合。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向完全随机 Spherize Direction(球面化方向) 将粒子方向朝球面方向混合，从它们的变换中心向外行进。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向从中心向外（与 Shape 设置为 Sphere 时的行为相同） Randomize Position(随机化位置) 以随机量移动粒子，直至达到指定值。此属性设置为 0 时，此设置不起作用。任何其他值都会对粒子的生成位置应用一些随机性 Rectangle Rectangle(矩形)\n属性 功能 Shape(形状) 发射体积的形状 Rectangle(矩形) 从矩形发射粒子。粒子从矩形向上移动 Texture(纹理) 用于为粒子着色和丢弃粒子的纹理 Position(位置) 将一个偏移应用于生成粒子的发射器形状 Rotation(旋转) 旋转生成粒子的发射器形状 Scale(缩放) 更改生成粒子的发射器形状的大小 Align to Direction(方向对齐) 根据粒子的初始行进方向定向粒子。如果想要模拟大块的汽车油漆在碰撞过程中飞出车身，此设置将非常有用。如果对该方向不太满意，也可通过在主模块中应用 Start Rotation 值来覆盖该设置 Randomize Direction(随机化方向) 将粒子方向朝随机方向混合。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向完全随机 Spherize Direction(球面化方向) 将粒子方向朝球面方向混合，从它们的变换中心向外行进。设置为 0 时，此设置不起作用。设置为 1 时，粒子方向从中心向外（与 Shape 设置为 Sphere 时的行为相同） Randomize Position(随机化位置) 以随机量移动粒子，直至达到指定值。此属性设置为 0 时，此设置不起作用。任何其他值都会对粒子的生成位置应用一些随机性 下方四个图标，用于可视化编辑场景中的形状，形状的选择会影响可发射粒子的区域，粒子的初始方向甚至粒子的初始速度\n图标名称 功能 形状小工具编辑模式 可视化编辑形状的大小 形状变换位置编辑模式 可视化移动形状的位置 形状变换旋转编辑模式 可视化旋转形状的角度 形状变换旋缩放编辑模式 可视化缩放形状的大小 Velocity over Lifetime(生命周期内速度) # 控制粒子在其生命周期内的速度\n属性 功能 Linear(线性) 粒子在 X、Y 和 Z 轴上的线性速度 Space(空间) 指定Linear X, Y, Z轴是参照本地空间还是世界空间 Orbital(轨道) 粒子围绕 X、Y 和 Z 轴的轨道速度 Offset(偏移) 轨道中心的位置，适用于轨道运行粒子 Radial(射线) 粒子远离/朝向中心位置的径向速度 Speed Modifier(速度修改器) 在当前行进方向上或周围向粒子的速度应用一个乘数 示例 # 要创建在特定方向上漂移的粒子，请使用 Linear X、Y 和 Z 曲线。\n要创建围绕中心位置旋转的粒子效果，请使用Orbital速度值。此外，可使用Radial速度值推动粒子朝向或远离中心位置。您可以使用Offset值为每个粒子定义自定义的旋转中心\n还可以使用此模块调整粒子系统中的粒子速度，而不影响粒子的方向，方法是将所有上述值保留为零，仅修改Speed Modifier值\nLimit Velocity Over Lifetime(生命周期内速度限制) # 控制粒子的速度在其生命周期内如何降低\n属性 功能 Separate Axes(分离轴) 将轴拆分为单独的 X、Y 和 Z 分量 Speed(速度) 设置粒子的速度限制 Space(空间) 选择速度限制是适用局部空间还是世界空间。仅当启用了Separate Axes时，此选项才可用 Dampen(抑制) 当粒子速度超过速度限制时，粒子速度降低的比例 Drag(阻力) 对粒子速度施加线性阻力 Multiply by Size(乘以大小) 启用此属性后，较大的粒子会更大程度上受到阻力系数的影响 Multiply by Velocity(乘以速度) 启用此属性后，较快的粒子会更大程度上受到阻力系数的影响 示例 # 该模块非常适合用于模拟会减慢粒子速度的空气阻力，特别是在使用下降曲线随时间推移而降低速度限制的情况下。例如，爆炸或烟花最初以极快的速度爆发，但是发射的粒子在穿过空气的过程中会迅速减速\nDrag选项通过提供基于粒子大小和速度施加不同阻力的选项，提供在物理上更加精确的空气阻力模拟\nInherit Velocity(继承速度) # 此模块控制粒子的速度如何随时间推移而受到其父对象移动的影响\n属性 功能 Mode(模式) 指定如何将发射器速度应用于粒子 Initial(初始) 每个粒子出生时将施加一次发射器的速度。粒子出生后对发射器速度的任何改变都不会影响该粒子 Current(当前) 发射器的当前速度将应用于每一帧上的所有粒子。例如，如果发射器减速，所有粒子也将减速 Multiplier(乘数) 粒子应该继承的发射器速度的比例 仅当Simulation Space在主模块中设置为World时，此模块才对粒子有影响\n示例 # 这种效果对于从移动对象发射粒子非常有用，例如汽车产生的尘云、火箭产生的烟雾、蒸汽火车烟囱产生的蒸汽，或者粒子最初应以所在对象的速度百分比移动的任何情况\n此外也可以使用曲线来影响随时间变化的效果。例如，可对新创建的粒子施加强烈的吸力，使吸力随时间推移而减少。这对于蒸汽火车烟雾可能有用，因为蒸汽火车烟雾会随着时间的推移而缓慢漂移并在发出后停止跟随火车\nForce Over Lifetime(生命周期内受力) # 通过此模块中指定的力（例如风或吸力）可对粒子加速\n属性 功能 X, Y, Z 在 X、Y 和 Z 轴上施加到每个粒子的力 Space(空间) 选择是在局部空间还是在世界空间中施力 Randomize(随机化) 使用Two Constants(两常数间随机)或Two Curves(两曲线间随机)模式时，此属性会导致在每个帧上在定义的范围内选择新的作用力方向。因此会产生更动荡、更不稳定的运动 示例 # 流体在移动时经常受到力的影响。例如，烟雾从火中升起时因周围热空气的拉升作用而略微加速。使用曲线在粒子生命周期内进行力的控制，可实现微妙的效果。根据前面的例子，烟雾最初会向上加速，但随着上升的空气逐渐冷却，力会减弱。从火焰冒出的浓烟可能最初会加速，然后随着烟雾的蔓延而减速，如果持续很长时间，甚至可能开始落到地上\nColor Over Lifetime(生命周期内颜色) # 此模块指定粒子的颜色和透明度在其生命周期中如何变化\n只有一个属性Color，表示粒子在其生命周期内的颜色变化\n示例 # 许多类型的天然和超现实粒子的颜色随时间而变化，因此该属性有许多用途。例如，白色强火花在通过空气时会冷却，魔法可能会突然变成彩虹色。但同样重要的还有Alpha(透明度)的变化。粒子在达到其生命周期终点时燃尽、褪色或消散是很常见的现象（例如，强火花、烟花和烟雾粒子），通过简单的梯度渐变即可产生这种效果\nColor By Speed(速度颜色) # 在此模块中可设置粒子的颜色根据粒子速度（每秒的距离单位）变化\n属性 功能 Color 在速度范围内定义的粒子的颜色渐变 Speed Range 颜色渐变映射到的速度范围的下限和上限（超出范围的速度将映射到渐变的端点） 示例 # 燃烧或发光的粒子（如火花）在空气中快速移动时会更明亮地燃烧（例如，当火花接触到更多氧气时），但随着它们减速时会略微变暗。要模拟这一点，可使用Color By Speed模块，使渐变在速度范围的上限为白色，而在下限为红色（在火花示例中，较快的粒子将显示为白色，而较慢的粒子为红色）\nSize over Lifetime(生命周期内大小) # 许多效果涉及根据曲线改变粒子大小，这些设置可在此模块中进行\n属性 功能 Separate Axes(分离轴) 在每个轴上独立控制粒子大小 Size(大小) 通过一条曲线定义粒子的大小在其生命周期内如何变化 示例 # 一些粒子通常会在远离发射点时发生大小变化，比如表示气体、火焰或烟雾的粒子。例如，随着时间的推移，烟雾往往会消散并占据更大的体积。为实现此目的，可将烟雾粒子的曲线设置为向上坡道曲线，随着粒子的存活时间而增加。此外还可使用Color Over Lifetime模块在烟雾蔓延时淡化烟雾，从而进一步增强此效果。\n对于燃料燃烧产生的火球，火焰粒子在发射后会趋于膨胀，但后期随着燃料用完和火焰消散而逐渐消失和收缩。在这种情况下，曲线会有一个先上升再下降到较小大小的“驼峰”\nSize by Speed(速度决定大小) # 在此模块中可创建能够根据速度（每秒的距离单位）改变大小的粒子\n属性 功能 Separate Axes(分离轴) 在每个轴上独立控制粒子大小 Size(大小) 通过曲线定义粒子在速度范围内的大小 Speed Range(速度范围) 大小曲线映射到的速度范围的下限和上限（超出范围的速度将映射到曲线的端点） 此模块不应与Limit Velocity Over Lifetime模块一起使用，除非您希望粒子在减速时改变其大小\n示例 # 某些情况下需要能够根据速度改变大小的粒子。例如，发生爆炸时，您可能希望小碎片的加速度高于更大的碎片。使用Size By Speed并结合简单的斜坡曲线（此曲线可随粒子大小减小使粒子速度按比例增加），即可实现这样的效果\nSpeed Range指定 X（宽度）、Y（高度）和 Z（深度）形状适用的值范围。仅当大小处于其中一种曲线模式时才应用Speed Range。快速的粒子将使用曲线右端的值缩放，而较慢的粒子将使用曲线左侧的值。例如，如果指定 10 到 100 之间的 Speed Range：\n低于 10 的速度将设置粒子大小与曲线的最左边相对应 高于 100 的速度将设置粒子大小与曲线的最右边相对应 10 到 100 之间的速度会将粒子大小设置为由曲线上与速度对应的点确定。在此示例中，速度为 55 将根据曲线的中点设置粒子大小 Rotation Over Lifetime(生命周期内旋转) # 在模块中可配置粒子在移动时旋转\n属性 功能 Separate Axes(分离轴) 允许根据每个轴指定旋转。启用此选项后，即可为 X、Y 和 Z 轴中的每个轴设置旋转 Angular Velocity(角速率) 旋转速度（以度/秒为单位） 右方下拉菜单可选择常量或曲线，两常数间随机或两曲线间随机\n属性 功能 Constant(常量) 粒子旋转的速度，以度/秒为单位 Curve(曲线) 角速度可设定为在粒子的生命周期内变化。检查器底部会出现一个曲线编辑器，可用于控制粒子在整个生命周期内的速度变化情况。如果勾选了 Separate Axes 复选框，则可为每个 X、Y 和 Z 轴赋予曲线速度值 Random Between Two Constants(两常数间随机) 角速度属性具有两个角度，允许在它们之间旋转 Random Between Two Curves(两曲线间随机) 角速度可设定为在粒子的生命周期（由曲线指定）内变化。在此模式下，两条曲线均为可编辑状态，每个粒子将在您定义的这两条曲线的范围之间选择一条随机曲线 示例 # 当粒子表示小型实体对象（例如爆炸产生的碎片）时，此设置很有用。分配随机的旋转值将使效果比粒子在飞行时保持直立更加真实。随机旋转也有助于打破粒子形状相似的规律性（重复多次的相同纹理可能会非常明显）\nRotation By Speed(按速度旋转) # 在此模块中可设置粒子的旋转根据粒子速度（每秒的距离单位）变化\n属性 功能 Separate Axes(分离轴) 为每个旋转轴独立控制旋转 Angular Velocity(角速度) 旋转速度（以度/秒为单位） Speed Range(速度范围) 大小曲线映射到的速度范围的下限和上限（超出范围的速度将映射到曲线的端点） 示例 # 当粒子表示在地面上移动的固体对象（例如滑坡的岩石）时，可使用此属性。可根据速度按比例设置粒子的旋转，使粒子在表面上滚动的效果具有令人信服\n仅当速度处于其中一种曲线模式时才应用Speed Range。快速的粒子将使用曲线右端的值旋转，而较慢的粒子将使用曲线左侧的值\nExternal Forces(外力) # 此属性可修改风区和粒子系统力场(Particle System Force Field)对系统发射的粒子的影响\n属性 功能 Multiplier(乘数) 应用于风区外力的比例值 Influence Filter(影响过滤器) 选择是基于图层遮罩 (Layer Mask)或通过显式列表 (List)包含力场亦或者两者皆有 Influence Mask(影响遮罩) 使用层遮罩来确定哪些力场影响此粒子系统。当Influence Filter设置为包含Layer Mask时，将显示此属性。 此属性在默认情况下设置为Everything，但您可以单独启用或禁用以下选项：\n-Nothing（自动取消勾选所有其他选项，将它们关闭）\n- Everything（自动勾选所有其他选项，将它们打开）\n- Default\n- TransparentFX\n- Ignore Raycast (射线投射器)\n- Water - UI List(列表) 定义可影响此粒子系统的力场的显式列表。当Influence Filter设置包含List时，将显示此属性 注：要通过此功能获得最佳效果，请使用粒子系统力场(Particle System Force Field)组件创建单独的游戏对象\n地形可添加风区来影响树在景观中的运动，启用此部分的功能允许风区吹动系统发射的粒子。通过Multiplier值可调整风对粒子的影响，因为风对粒子的吹动作用通常比树枝更强烈\nNoise(噪音) # 使用此模块可为粒子移动添加湍流，发射后的粒子会抖动，或者说被干扰\n属性 功能 Separate Axes(分离轴) 在每个轴上独立控制强度和重新映射 Strength(强度) 通过常量或曲线曲线定义噪声在粒子的生命周期内对粒子的影响有多强。值越高，粒子移动越快和越远 Frequency(频率) 低值会产生柔和、平滑的噪声，而高值会产生快速变化的噪声。此属性可控制粒子改变行进方向的频率以及方向变化的突然程度 Scroll Speed(滚动速度) 随着时间的推移而移动噪声场可产生更不可预测和不稳定的粒子移动，即随机性 Damping(阻尼) 启用此属性后，强度与频率成正比。将这些值绑在一起意味着可在保持相同行为但具有不同大小的同时缩放噪声场 Octaves(倍率) 指定组合多少层重叠噪声来产生最终噪声值。使用更多层可提供更丰富、更有趣的噪声，但会显著增加性能成本 Octave Multiplier(倍率乘数) 对于每个附加的噪声层，按此乘数调整频率 Octave Scale(倍率缩放) 对于每个附加的噪声层，按此比例降低强度 Quality(质量) 较低的质量设置可显著降低性能成本，但也会影响噪声的有趣程度。请使用能为您提供所需行为的最低质量以获得最佳性能 Remap(重新映射) 将最终噪声值重新映射到不同的范围 Remap Curve(重新映射曲线) 描述最终噪声值如何变换的曲线。例如，可使用此选项来创建从高点开始并以零结束的曲线，从而选择噪声场的较低范围并忽略较高范围 Position Amount(位置数量) 用于控制噪声对粒子位置影响程度的乘数 Rotation Amount(旋转量) 用于控制噪声对粒子旋转（以度/秒为单位）影响程度的乘数 Size Amount(尺寸量) 用于控制噪声对粒子大小影响程度的乘数 示例 # 为粒子添加噪声是创建有趣方案和效果的简单有效方法。例如，想象一下火焰中的余烬是如何移动的，或者烟雾在移动时是如何旋转的。强烈的高频噪声可用于模拟火焰余烬，而柔和的低频噪声更适合模拟烟雾效果\n为了最大程度控制噪声，可启用 Separate Axes 选项。此选项允许您在每个轴上独立控制强度和重新映射\n使用的噪声算法基于一种称为“卷曲噪声”(Curl Noise) 的技术，而该技术在内部使用多个柏林噪声 (Perlin Noise) 样本来创建最终噪声场\nQuality窗口中的设置控制着生成的独特噪声样本数量。使用 Medium 和 Low 设置时，使用的柏林噪声样本较少，这些样本将在多个轴上重用，但会组合在一起以尽可能进行重用并隐藏这样的重用。这意味着当使用较低质量的设置时，噪声可能看起来不那么动态和多样化。但是，使用较低质量的设置时，可以获得显著的性能优势\nCollision(碰撞) # 此模块控制粒子如何与场景中的游戏对象碰撞。使用第一个下拉选单可定义碰撞设置是应用于Planes还是应用于World。如果选择World，请使用Collision Mode下拉选单定义碰撞设置是应用于2D还是3D世界\nPlanes(平面) # 选择某物体作为一个板子与粒子碰撞\n属性 功能 类型 选择Planes模式 Planes(平面) 用于定义碰撞平面的变换的可扩展列表 Visualization(可视化) 选择要将场景视图中的碰撞平面辅助图标显示为线框网格还是实体平面 Scale Plane(缩放平面) 用于可视化的平面大小 Dampen(抑制) 粒子碰撞后损失的速度比例 Bounce(反弹) 粒子碰撞后从表面反弹的速度比例 Lifetime Loss(生存期损失) 粒子碰撞后损失的总生命周期比例 Min Kill Speed(最小消亡速度) 碰撞后运动速度低于此速度的粒子将从系统中予以移除 Max Kill Speed(最大消失速度) 碰撞后运动速度高于此速度的粒子将从系统中予以移除 Radius Scale(半径缩放) 允许调整粒子碰撞球体的半径，使其更贴近粒子图形的可视边缘 Send Collision Messages(发送碰撞消息) 如果启用此属性，则可从脚本中通过OnParticleCollision函数检测粒子碰撞 Visualize Bounds(可视化边界) 在场景视图中将每个粒子的碰撞边界渲染为线框形状 World(世界) # 与世界中任何物品碰撞\n属性 功能 类型 选择World模式 Collision Mode(模式) 3D 或 2D Dampen(抑制) 粒子碰撞后损失的速度比例 Bounce(反弹) 粒子碰撞后从表面反弹的速度比例 Lifetime Loss(生存期损失) 粒子碰撞后损失的总生命周期比例 Min Kill Speed(最小消亡速度) 碰撞后运动速度低于此速度的粒子将从系统中予以移除 Max Kill Speed(最大消失速度) 碰撞后运动速度高于此速度的粒子将从系统中予以移除 Radius Scale(半径缩放) 调整粒子碰撞球体的半径，使其更贴近粒子图形的可视边缘 Collision Quality(碰撞质量) 使用下拉选单来设置粒子碰撞的质量。此设置会影响有多少粒子可以穿过碰撞体。在较低的质量水平下，粒子有时会穿过碰撞体，但需要的计算资源较少 High(高) 碰撞始终使用物理系统来检测碰撞结果。此设置是最耗费资源但也是最准确的选项 Medium (Static Colliders)(中等(静态碰撞体)) 碰撞使用一组体素来缓存先前的碰撞，从而在以后的帧中更快地重用。 Low (Static Colliders)(低(静态碰撞体)) 碰撞使用一组体素来缓存先前的碰撞，从而在以后的帧中更快地重用。Medium和Low之间的唯一区别是粒子系统在每帧查询物理系统的次数。Medium每帧的查询次数多于Low。请注意，此设置仅适用于从不移动的静态碰撞体 Collides With(碰撞对象) 粒子只会与所选层上的对象发生碰撞 Max Collision Shapes(最大碰撞形状) 粒子碰撞可包括的碰撞形状个数。多余的形状将被忽略，且地形优先 Enable Dynamic Colliders(启用动态碰撞器) 允许粒子也与动态对象碰撞（否则仅使用静态对象）。动态碰撞体是未配置为 Kinematic 的任何碰撞体。 选中此选项可将这些碰撞体类型包含在粒子发生碰撞时响应的对象组内。如果取消选中此选项，粒子仅响应与静态碰撞体的碰撞 Voxel Size(体素大小) 体素 (voxel) 表示三维空间中的常规网格上的值。使用Medium或Low质量碰撞时，Unity 会在网格结构中缓存碰撞。此设置控制着网格大小。较小的值可提供更高的准确性，但会占用更多内存，效率也会降低。 注意：仅当Collision Quality设置为Medium或Low时，才能访问此属性 Collider Force(碰撞器力度) 在粒子碰撞后对物理碰撞体施力。这对于用粒子推动碰撞体很有用 Multiply by Collision Angle(乘以碰撞角) 向碰撞体施力时，根据粒子与碰撞体之间的碰撞角度来缩放力的强度。掠射角将比正面碰撞产生更小的力 Multiply by Particle Speed(乘以粒子速度) 向碰撞体施力时，根据粒子的速度来缩放力的强度。快速移动的粒子会比较慢的粒子产生更大的力 Multiply by Particle Size(乘以粒子大小) 向碰撞体施力时，根据粒子的大小来缩放力的强度。较大的粒子会比较小的粒子产生更大的力 Send Collision Messages(发送碰撞消息) 如果选中此复选框，则允许从脚本中通过OnParticleCollision函数检测粒子碰撞 Visualize Bounds(可视化边界) 在场景视图中预览每个粒子的碰撞球体 示例 # 当其他对象围绕粒子系统时，通常情况下，粒子与这些对象相互作用才会使效果更有说服力。例如，水或碎片应该被坚固的墙壁阻挡而非直接穿过墙壁。启用Collision模块后，粒子可与场景中的对象发生碰撞\n通过从弹出菜单中选择World模式，可设置粒子系统来使其粒子与场景中的任何碰撞体碰撞。此外，也可使用Collides With属性根据碰撞体所在的层来禁用碰撞体。弹出菜单还有一个Planes模式选项，可用于向场景中添加一组不需要碰撞体的平面。此选项对于简单的地板、墙壁和类似对象非常有用，并且处理器开销低于World模式\n启用Planes模式后，可通过Planes属性添加一组变换（通常为空游戏对象）。平面在对象的局部XZ平面中无限延伸，其中以正Y轴表示平面的法线矢量。为了协助开发，无论对象本身是否具有任何可见的网格，平面都将在场景中显示为辅助图标。辅助图标可显示为线框网格或实体平面，也可进行缩放。但是，缩放仅适用于可视化；碰撞平面本身在场景中无限延伸\n启用碰撞后，粒子的大小有时会成为问题，因为它的图形在与表面接触时可能被裁剪。这种情况可能导致粒子在停止或反弹之前在一定程度上“下沉”到表面中。Radius Scale属性通过定义粒子的近似圆形半径（以其实际大小的百分比形式）来解决此问题。此大小信息用于防止裁剪并避免下沉效应\n当粒子表示实体对象时，Dampen和Bounce属性非常有用。例如，砾石在抛出时往往会在坚硬的表面上反弹，但是雪球粒子在碰撞时可能会失去速度。Lifetime Loss和Min Kill Speed有助于减少碰撞后残留颗粒的影响。例如，火球在空中飞行时可能会持续几秒钟，但在碰撞后，单独的火焰粒子应该快速消散\n如果启用了Send Collision Messages，还可从脚本中检测粒子碰撞。脚本可附加到带有粒子系统的对象，也可附加到带有碰撞体的对象。通过检测碰撞，可将粒子用作游戏中的活动对象，例如飞弹、魔法和能量块 (power-up)\nWorld Collision Quality(碰撞质量) # World Collision 模块具有 Collision Quality 属性，可将其设置为 High、Medium 或 Low。当 Collision Quality 设置为 Medium (Static Colliders) 或 Low (Static Colliders) 时，碰撞使用一组体素（3D 网格上的值）来缓存先前的碰撞，从而在以后的帧中快速重用。\n该缓存由每个体素中的平面组成，其中的平面表示该位置处的碰撞表面。在每个帧上，Unity 都会检查缓存中是否有该粒子位置的平面，如果有，则 Unity 将其用于碰撞检测。否则会查询物理系统。如果返回了碰撞，则会将其添加到缓存中，以便在后续帧上快速进行查询。\n这是近似算法，因此可能存在一些缺失的碰撞。可通过减小 Voxel Size 值来帮助解决这个问题；但是，这样做会占用额外的内存，效率也会降低。\nMedium 和 Low 之间的唯一区别是允许系统在每帧查询物理系统的次数。Low 每帧的查询次数少于 Medium。一旦超出每帧预算，只能将缓存用于所有其余粒子。这样一来可能导致缺失的碰撞增加，直到更全面填充缓存为止。\nTriggers(触发器) # 内置粒子系统的Triggers模块可用于基于粒子与场景中一个或多个碰撞体的相互作用来访问和修改粒子。启用此模块时，粒子系统将在附加的脚本上调用OnParticleTrigger()回调，因此可以根据粒子相对于场景中碰撞体的位置来访问粒子列表\n添加碰撞体 # 首先，指定粒子可与场景中的哪些碰撞体进行碰撞。为此，请将一个或多个碰撞体分配给Colliders列表属性。要增加列表中的碰撞体数量，请单击 Colliders 列表下方的 Add (+) 按钮。要从列表中移除某个碰撞体，请选择该碰撞体，然后单击 Remove (-) 按钮。如果尚未将碰撞体分配给列表的索引，则可以使用空条目右侧较小的 Add (+) 按钮来创建和分配新的碰撞体。这将创建一个新的游戏对象作为粒子系统的子项，并将球形碰撞体附加到该游戏对象，然后将碰撞体分配给空条目\n添加碰撞体后，可指定当粒子满足传递特定触发事件类型的条件时将执行的操作。事件类型有四种，它们描述了粒子如何与碰撞体相互作用\n属性 # 属性 描述 Inside(内部) 粒子在碰撞体的边界内会发生什么 Outside(外部) 粒子在碰撞体的边界外会发生什么 Enter(进入) 粒子进入碰撞体的边界会发生什么 Exit(退出) 粒子退出碰撞体的边界会发生什么 Ignore 忽略粒子。您无法在OnParticleTrigger()回调函数中访问粒子 Kill 销毁粒子。您无法在OnParticleTrigger()回调函数中访问粒子 Callback 允许您在OnParticleTrigger()回调函数中访问粒子 Radius Scale(半径缩放) 粒子的碰撞体边界。允许您更紧密地将粒子的碰撞体边界匹配到粒子的视觉外观。如果粒子为圆形且其纹理具有淡入淡出效果，这将很有用，因为默认粒子碰撞体将在粒子达到视觉效果之前位于触发器内。请注意，当事件实际触发时，此设置不会更改，但是可以延迟或提前达到触发器的视觉效果。 • 输入 1 可以使粒子碰撞体保持同一大小，并使事件在粒子接触碰撞体时发生 • 输入小于 1 的值可以使粒子碰撞体更小，并使触发看起来是在粒子穿透碰撞体之前发生 • 输入大于 1 的值可以使粒子碰撞体更大，并使触发看起来是在粒子穿透碰撞体之后发生 Visualize Bounds(可视化边界) 指示是否在场景视图中显示每个粒子的碰撞体边界。启用此属性可显示碰撞体边界，而禁用则可隐藏碰撞体边界。 Sub Emitters(子发射器) # 在此模块中可设置子发射器，即子级粒子系统。这些子发射器是在粒子生命周期的某些阶段在粒子位置处创建的附加粒子发射器\n配置一个子发射器列表，并选择它们的触发条件以及它们从父粒子继承的属性\n属性 描述 触发条件 触发子发射器的条件 Birth(出生) 跟随父级出生时发射 Collision(碰撞) 父级粒子与对象发生碰撞时 Death(死亡) 父级粒子销毁时 Trigger(触发器) 父级粒子与触发碰撞体相互作用时 Manual(用户手册) 仅在通过脚本进行请求时触发 Inherit(继承) 将属性从父粒子转移到每个新创建的粒子。可转移属性包括颜色、尺寸、旋转角度、生命周期和持续时间。要控制速度的继承方式，请在子发射器系统上配置Inherit Velocity模块 Emit Probability(发射概率) 配置子发射器事件的触发概率。值为 1 可以保证事件将触发，而更小的值则会降低概率 请注意，Collision、Trigger、Death 和 Manual事件只能使用子级粒子的Emission模块中的爆发发射\n示例 # 许多类型的粒子都会在其生命周期的不同阶段产生一些效果，而这也可使用粒子系统来实现。例如，子弹离开枪管时可能伴随着一缕烟尘，火球可能会在撞击时爆炸。您可以使用子发射器来创建诸如此类的效果。\n子发射器是在场景中创建的或来自预制件的普通粒子系统对象。这意味着子发射器还可以有自己的子发射器（这种类型的布置对于像烟花这样的复杂效果很有用）。但是，虽然使用子发射器生成大量粒子非常容易，但这可能非常耗费资源。\nTexture Sheet Animation(纹理表格动画) # 粒子的图形不必是静止图像。此模块允许您将纹理视为可作为动画帧进行播放的一组单独子图像\n使用此模块为特殊的纹理，即有许多图像排列的纹理\nGrid(网格)模式属性 # 属性 功能 Mode(模式) 选择Grid(网格)模式 Tiles(瓦片) 纹理在 X（水平）和 Y（垂直）方向上划分的区块数量 Animation(动画) Animation模式可设置为Whole Sheet(整张工作表)或 Single Row(单行)（即Sprite图集的每一行代表一个单独的动画序列） Row Mode(行模式) 粒子系统从纹理帧中选择一行以生成动画。仅当Animation模式设置为Single Row时，此属性才可用 Custom(自定义) 将纹理帧的特定行用于动画 Random(随机) 为每个粒子随机选择一行来生成动画 Mesh Index(网格索引) 根据分配给粒子的网格索引(Mesh Index)选择一行。需要确保使用特定网格的粒子也要使用相同的纹理时，此功能很有用 Row(行) 从精灵图集选择特定行以生成动画。仅当选择Single Row模式且选择Custom 时，此选项才可用 Time Mode(时间模式) 选择粒子系统如何在动画中对帧进行采样 Lifetime(生存期) 在粒子的生命周期内使用动画曲线对帧进行采样 Speed(速度) 根据粒子的速度对帧进行采样。速度范围指定选择帧的最小和最大速度范围 FPS 根据指定的每秒帧数值对帧进行采样 Frame over Time(随时间推移的帧) 通过一条曲线指定动画帧随着时间的推移如何增加 Start Frame(开始帧) 允许指定粒子动画应从哪个帧开始（对于在每个粒子上随机定相动画非常有用） Cycles(周期) 动画序列在粒子生命周期内重复的次数 Affected UV Channels(受影响的UV通道) 允许具体指定粒子系统影响的 UV 流 Sprite模式属性 # 属性 功能 Mode(模式) 选择Sprites模式 Time Mode(时间模式) 选择粒子系统如何在动画中对帧进行采样 Lifetime(生存期) 在粒子的生命周期内使用动画曲线对帧进行采样 Speed(速度) 根据粒子的速度对帧进行采样。速度范围指定选择帧的最小和最大速度范围 FPS 根据指定的每秒帧数值对帧进行采样 Frame over Time(随时间推移的帧) 通过一条曲线指定动画帧随着时间的推移如何增加 Start Frame(开始帧) 允许指定粒子动画应从哪个帧开始（对于在每个粒子上随机定相动画非常有用） Cycles(周期) 动画序列在粒子生命周期内重复的次数 Enabled UV Channels(受影响的UV通道) 允许具体指定粒子系统影响的 UV 流 示例 # 粒子动画通常比角色动画更简单，细节级别更低。在可单独看到粒子的系统中，动画可用于表现动作或移动。例如，火焰可能会闪烁，成群的昆虫可能振动或颤抖，好像在拍打翅膀。在粒子形成单个连续实体（如云团）的情况下，动画粒子有助于增添能量和运动效果\n您可以使用Single Row模式为粒子创建单独的动画序列，并通过脚本在动画之间切换。这对于创建变体或在碰撞后切换到不同动画非常有用。Random Row选项非常适合用于打破粒子系统中明显的规律性（例如，一组火焰对象全部一遍又一遍重复完全相同的闪烁动画）。此选项也用于每行的单个帧，从而生成具有随机图形的粒子。此选项可用于打破诸如云之类的对象中的规则性，或者用于从单个系统产生不同类型的碎片或其他对象。例如，一把大口径枪可能会发射出一堆钉子、螺栓、球和其他飞弹，汽车碰撞效果可能会导致发射出弹簧、汽车油漆、螺钉和其他金属部件\nRow Mode属性用于打破粒子系统中明显的规律性（例如，一组游戏对象全部一遍又一遍重复完全相同的闪烁动画）。要生成具有随机图形的粒子，请将此属性用于每行的单个帧。此属性可用于打破诸如云之类的单个系统中的规律性，或者用于产生不同类型的碎片。例如，一把枪可能会发射出一堆钉子、螺栓和其他飞弹，汽车碰撞效果可能会发射出弹簧、汽车油漆、螺钉和其他金属部件\nUV 翻转是为效果添加更多视觉多样性而无需创建其他纹理的好方法\n从Mode下拉选单中选择Sprites选项，可以定义要为每个粒子显示的Sprites列表，而不是使用纹理上的一组常规帧。使用此模式可以利用Sprite的许多功能，例如Sprite Packer、自定义轴心和每个Sprite帧的不同大小。Sprite Packer可帮助在不同粒子系统之间共享材质，方法是将纹理整理成图集，从而通过动态批处理 (Dynamic Batching)提高性能。使用此模式时需要注意一些限制。最重要的一点，附加到粒子系统的所有Sprite必须共享相同的纹理。通过使用Multiple Mode Sprite或使用Sprite Packer即可实现此目的。如果为每个Sprite使用自定义轴心点，请注意不能在它们的帧之间进行混合，因为每个帧之间的几何体会有所不同。仅支持简单Sprite，而不支持 9 切片Sprite。另外请注意，网格粒子不支持自定义轴心以及变化的Sprite大小\nLights(光线) # 使用此模块可将实时光照添加到一部分粒子\n属性 功能 Light(灯光) 分配一个光照预制件来描述粒子光照外观 Ratio(比例) 一个介于 0 和 1 之间的值，表示将接受光照的粒子的比例 Random Distribution(随机分布) 选择是随机分配还是定期分配光照。设置为 true 时，每个粒子都有根据 Ratio 值随机接受光照的机会。较高的值可增加粒子接受光照的概率。设置为 false 时，由 Ratio 控制新创建的粒子接受光照的频率（例如，每第 N 个粒子将接受光照） Use Particle Color(使用粒子颜色) 设置为 True 时，光照的最终颜色将通过其附加到的粒子的颜色进行调制。如果设置为 False，则使用光照颜色而不进行任何修改 Size Affects Range(大小影响范围) 启用此属性后，在光照中指定的范围 (Range)将受到粒子大小的影响 Alpha Affects Intensity(Alpha影响强度) 启用此属性后，光照的强度 (Intensity)将受到粒子 Alpha 值的影响，即透明度的强度 Range Multiplier(范围乘数) 使用此曲线在粒子的生命周期内将一个自定义乘数应用于光照范围 Intensity Multiplier(强度乘数) 使用此曲线在粒子的生命周期内将一个自定义乘数应用于光照强度 Maximum Lights(最大灯光数量) 使用此设置可避免意外创建大量光照，大量光照可能会使 Editor 无响应或使应用程序运行速度非常慢 示例 # Lights 模块是一种为粒子效果添加实时光照的快速方法。此模块可用于使系统将光照投射到周围环境，例如可用于火、烟花或闪电。此外，还可通过该模块让光照从所附着的粒子继承各种属性。这样可以使粒子效果本身的发光更加逼真。例如，为了实现此目的，可使光照随其粒子淡出并使它们共享相同的颜色\n该模块可以非常快速地创建大量实时光照，但实时光照有很高的性能成本，尤其是在前向渲染模式下。如果光照还要投射阴影，性能成本会更高。为了防止意外调整发射速率并因此导致创建数千个实时光照，应使用 Maximum Lights 属性。创建的光照数量超过目标硬件的管理能力可能会导致速度降低和无响应的问题\nTrails(拖尾) # 使用此模块可将轨迹添加到一部分粒子。此模块与轨迹渲染器 (Trail Renderer) 组件共享许多属性，但提供了将轨迹轻松附加到粒子以及从粒子继承各种属性的功能。轨迹可用于各种效果，例如子弹、烟雾和魔法视觉效果\n属性 功能 Mode(模式) 选择如何为粒子系统生成轨迹 Particle(粒子) 创建每个粒子在自身路径中留下固定轨迹的效果 Ribbon(条带) 创建根据存活时间连接每个粒子的轨迹带 Ratio(比例) 一个介于 0 和 1 之间的值，表示已分配轨迹的粒子的比例。Unity 随机分配轨迹，因此该值表示概率。 Lifetime(生存期) 轨迹中每个顶点的生命周期，表示为所属粒子的生命周期的乘数。当每个新顶点添加到轨迹时，该顶点将在其存在时间超过其总生命周期后消失。 Minimum Vertex Distance(最小顶点距离) 定义粒子在其轨迹接收新顶点之前必须经过的距离。 World Space(世界空间) 启用此属性后，即便使用Local Simulation Space，轨迹顶点也不会相对于粒子系统的游戏对象移动。相反，轨迹顶点将被置于世界空间中，并忽略粒子系统的任何移动 Die With Particles(随粒子消失) 如果选中此框，轨迹会在粒子死亡时立即消失。如果未选中此框，则剩余的轨迹将根据自身的剩余生命周期自然到期 Ribbon Count(条带数) 选择要在整个粒子系统中渲染的轨迹带数量。值为 1 将创建连接每个粒子的单个轨迹带。但是，大于 1 的值将创建连接每第 N 个粒子的轨迹带。例如，使用值 2 时，将有一条轨迹带连接粒子 1、3、5，另一条轨迹带连接粒子 2、4、6，以此类推。粒子的排序取决于它们的存活时间 Split Sub Emitter Ribbons(分割子发射器条带) 用作子发射器的系统上启用此属性时，从同一父系统粒子生成的粒子将共享一个轨迹带 Attach Ribbons to Transform(将条带附加到变换组件) 将每个条带连接到变换组件的位置 Texture Mode(纹理模式) 控制如何将纹理应用于粒子轨迹 Stretch(伸展) 沿轨迹的整个长度映射纹理一次 Tile(平铺) 每 N 个距离重复纹理。重复率是基于Material中的Tiling参数进行控制的 DistributePerSegment(分布每段) 沿轨迹的整个长度映射纹理一次，并假设所有顶点均匀分布 RepeatPerSegment(重复每段) 沿轨迹重复纹理，每个轨迹段重复一次。重复率是基于Material中的Tiling参数进行控制的 Size affects Width(大小会影响宽度) 轨迹宽度受粒子大小影响 Size affects Lifetime(大小会影响生命周期) 轨迹生命周期受粒子大小影响 Inherit Particle Color(继承粒子颜色) 轨迹颜色由粒子颜色调制 Color over Lifetime(生命周期内颜色) 通过一条曲线控制整个轨迹在其附着粒子的整个生命周期内的颜色 Width over Trail(拖尾宽度) 通过一条曲线控制轨迹沿其长度的宽度 Color over Trail(拖尾颜色) 通过一条曲线控制轨迹沿其长度的颜色 Generate Lighting Data(生成照明数据) 通过启用此属性（选中复选框），可在构建轨迹几何体时包含法线和切线。这样允许它们使用具有场景光照的材质，例如通过标准着色器，或通过使用自定义着色器 Shadow Bias(阴影偏离) 设置沿着光照方向的阴影移动量以消除阴影瑕疵 使用Renderer模块指定拖尾材质 (Trail Material)\n其他 # Unity 在每个顶点处从颜色渐变 (Color Gradient) 中采样颜色，并在每个顶点之间进行线性的颜色插值。向线渲染器 (Line Renderer) 添加更多顶点可以更接近详细的颜色渐变\nCustom Data(自定义数据) # Custom Data模块允许您在Editor中定义要附加到粒子的自定义数据格式。您也可以在脚本中进行此设置。有关如何在脚本中设置自定义数据并将该数据发送到着色器的更多信息，请参阅 粒子系统顶点流的相关文档。\n数据可以是矢量 (Vector)的形式，包含最多 4 个 MinMaxCurve组件或颜色 (Color)，此颜色是支持HDR的 MinMaxGradient。使用此数据可在脚本和着色器中驱动自定义逻辑。\n可自定义每个曲线/渐变的默认标签，只需单击它们并输入上下文名称即可。将自定义数据传递给着色器时，了解如何在着色器中使用该数据非常有用。例如，曲线可用于自定义的Alpha测试，或者可使用渐变向粒子添加辅助颜色。通过编辑标签，很容易在UI中保留每个自定义数据条目的记录。\nRenderer(渲染器) # Renderer 模块的设置决定了粒子的图像或网格如何被其他粒子变换、着色和过度绘制。\n属性 功能 Render Mode(渲染模式) 如何从图形图像（或网格）生成渲染图像 Billboard(广告牌) 粒子始终面向摄像机 Stretched Billboard(伸展广告牌) 粒子面向摄像机，但会应用各种缩放，即以下三种 Camera Scale(摄像机缩放) 根据摄像机运动拉伸粒子。将此值设置为 0 可禁用摄像机运动拉伸 Velocity Scale(速度比例) 根据粒子速度按比例拉伸粒子。将此值设置为 0 可禁用基于速度的拉伸 Length Scale(长度比例) 沿着粒子的速度方向根据粒子当前大小按比例拉伸粒子。将此值设置为 0 会使粒子消失，相当于 0 长度 Horizontal Billboard(水平广告牌) 粒子平面与 XZ“地板”平面平行 Vertical Billboard(垂直广告牌) 粒子在世界 Y 轴上直立，但转向面向摄像机 Mesh(网格) 从 3D 网格而非从纹理渲染粒子 None(无) 使用Trails模块时，如果只想渲染轨迹并隐藏默认渲染，则可使用此属性 Normal Direction(法线方向) 用于粒子图形的光照法线的偏 差。值为 1.0 表示法线指向摄像机，而值为 0.0 表示法线指向屏幕中心（仅限公告牌模式） Material(材质) 用于渲染粒子的材质 Trail Material(拖尾材质) 用于渲染粒子轨迹的材质。仅当启用了Trails模块时，此选项才可用 Sort Mode(排序模式) 绘制粒子（因此覆盖粒子）的顺序。可能的值为By Distance (from the Camera)、Oldest in Front和Youngest in Front，即通过距离、最旧的放前面和最新的放前面。系统中的每个粒子都将根据此设置进行排序 Sorting Fudge(排序校正) 粒子系统排序的偏差。较低的值会增加粒子系统在其他透明游戏对象（包括其他粒子系统）上绘制的相对几率。此设置仅影响整个系统在场景中的显示位置，而不会对系统中的单个粒子执行排序 Min Particle Size(最小粒子大小) 最小粒子大小（无论其他设置如何），表示为视口大小的一个比例。请注意，仅当 Rendering Mode 设置为 Billboard 时，才应用此设置 Max Particle Size(最大粒子大小) 最大粒子大小（无论其他设置如何），表示为视口大小的一个比例。请注意，仅当 Rendering Mode 设置为 Billboard 时，才应用此设置 Render Alignment(渲染对齐) 使用下拉选单选择粒子公告牌面向的方向 View(视图) 粒子面向摄像机平面 World(世界) 粒子与世界轴对齐 Local(局部) 粒子与游戏对象的变换组件对齐 Facing(面对) 粒子面向摄像机游戏对象的直接位置 Velocity(速度) 使网格模型化粒子模型正面方向和速度方向一样 Flip(翻转) 在指定轴上镜像一定比例的粒子。较高的值会翻转更多的粒子 Enable GPU Instancing(启用网格GPU实例化) 控制是否要使用 GPU 实例化来渲染粒子系统。需要使用网格渲染模式并使用兼容的着色器 Allow Roll(允许滚动) 控制面向摄像机的粒子是否可以围绕摄像机的 Z 轴旋转。禁用此属性对于 VR 应用特别有用，因为在此应用中 HMD 滚动可能会给粒子系统带来不良后果 Pivot(轴心) 修改旋转粒子的中心轴心点。此值是粒子大小的乘数 Visualize Pivot(可视化枢轴) 在 Scene 视图中预览粒子轴心点 Masking(遮罩) 设置粒子系统渲染的粒子在与精灵遮罩交互时的行为方式 No Masking(无遮罩) 粒子系统不与场景中的任何精灵遮罩交互。这是默认选项 Visible Inside Mask(遮罩内可见) 粒子在由精灵遮罩覆盖的地方是可见的，而在遮罩外部不可见 Visible Outside Mask(遮罩外可见) 粒子在精灵遮罩外部是可见的，而在遮罩内部不可见。精灵遮罩会隐藏其覆盖的粒子部分 Apply Active Color Space(应用当前颜色空间) 在线性颜色空间中渲染时，系统会在将粒子颜色上传到 GPU 之前从伽马空间转换粒子颜色 Custom Vertex Streams(自定义顶点流) 配置材质的顶点着色器中可用的粒子属性 Cast Shadows(投射阴影) 如果启用此属性，阴影投射光源照在粒子系统上时将产生阴影 Off 禁用阴影 On 启用阴影 Two-Sided 允许从网格的任一侧投射阴影（这意味着不考虑背面剔除） Shadows Only 使阴影可见，但网格本身不可见 Receive Shadows(接受阴影) 决定阴影是否可投射到粒子上。只有不透明材质才能接受阴影 Shadow Bias(阴影偏离) 沿着光照方向移动阴影以消除因使用公告牌来模拟体积而导致的阴影瑕疵 Motion Vectors(运动矢量) 设置是否使用运动矢量来跟踪此粒子系统的变换组件从一帧到下一帧的每像素屏幕空间运动 Camera Motion Only(仅摄像机移动) 仅使用摄像机移动来跟踪运动。 Per Object Motion(每对象移动) 使用特定通道来跟踪此渲染器的运动。 Force No Motion(强制无动作) 不跟踪运动。 Sorting Layer ID 渲染器排序图层的名称 Order in Layer(图层顺序) 此渲染器在排序图层中的顺序 Light Probes(光照探测器) 基于探针的光照插值模式 Reflection Probes(反射探测器) 如果启用此属性，并且场景中存在反射探针，则会为此游戏对象拾取反射纹理，并将此纹理设置为内置的着色器 uniform 变量 Anchor Override(锚点覆盖) 使用光照探针或反射探针系统时用变换来确定插值位置 网格必须设置为read/write enabled才能在粒子系统上工作。如果在Editor中分配网格，Unity 会为您进行此处理，但如果您想在运行时分配不同的网格，则需要自己处理此设置。\n其他 # 使用 2D 公告牌图形时，不同的选项可用于不同的效果：\nBillboard模式适合用于表示从任何方向看起来大致相同的体积的粒子（例如云）\nHorizontal Billboard模式可在粒子覆盖地面时（例如目标指示器和魔法效果）或者是平行于地面飞行或浮动的扁平对象时（例如飞镖）使用\nVertical Billboard模式使每个粒子保持直立并垂直于 XZ 平面，但允许粒子围绕其 y 轴旋转。使用正交摄像机并希望粒子大小保持一致时，此模式可能会有用\nStretched Billboard模式通过与传统动画器使用的“拉伸或挤压”技术类似的方式突出粒子的表观速度。请注意，在Stretched Billboard模式下，粒子将看齐面向摄像机，并且还向粒子速度看齐。无论Velocity Scale值如何，都会发生此看齐；即使Velocity Scale设置为 0，此模式下的粒子仍然向速度看齐\nNormal Direction可用于在扁平矩形公告牌上创建球形阴影。如果使用的材质将光照应用于粒子，此设置有助于创建 3D 粒子的视觉效果。此设置仅与Billboard渲染模式结合使用\n"},{"id":31,"href":"/div/trail_renderer/","title":"Trail Renderer","section":"Docs","content":"轨迹渲染器 (Trail Renderer) 组件在移动的游戏对象后面渲染一条多边形轨迹。此组件可用于强调移动对象的运动感，或突出移动对象的路径或位置。飞弹背后的轨迹为飞弹的飞行轨道增添了视觉清晰度；来自飞机机翼尖端的凝结尾迹是现实生活中出现的轨迹效果的一个例子\n创建 # 在层级中右击Effects(效果)-Trail(拖尾)\n轨迹设置 # 属性 功能 Width(宽度) 定义宽度值和曲线值以控制轨迹沿其长度的宽度。双击可创建新的顶点 Time(时间) 定义轨迹中某个点的生命周期（以秒为单位） Min Vertex Distance(最小顶点距离) 轨迹中两点之间的最小距离（采用世界单位） AutoDestruct(自动销毁) 启用此属性可在附加到Trail Renderer组件的游戏对象静止Time秒之后销毁该游戏对象 Emitting(正在发射) 启用此属性后，Unity 会在轨迹中添加新点。禁用此属性后，Unity 不会向轨迹中添加新点。使用此属性可暂停和恢复轨迹生成功能 Color(颜色) 定义一个渐变来控制轨迹沿其长度的颜色 Corner Vertices(角顶点) 此属性指示在绘制轨迹中的角时使用多少个额外顶点。增加此值可使轨迹的角显得更圆 End Cap Vertices(末端顶点) 此属性指示使用多少个额外顶点在轨迹上创建端盖。增加此值可使轨迹的端盖显得更圆 Alignment(对齐) 设置轨迹面向的方向 View(视图) 轨迹面向摄像机 TransformZ(变换Z) 轨迹朝向其变换组件的 Z 轴 Texture Mode(纹理模式) 控制如何将纹理应用于轨迹 Stretch(伸展) 沿轨迹的整个长度映射纹理一次 Tile(平铺) 基于轨迹长度（采用世界单位）沿轨迹重复纹理。要设置平铺率，请使用 Material.SetTextureScale() DistributePerSegment(按段分配) 沿轨迹的整个长度映射纹理一次（假设所有顶点均匀分布） RepeatPerSegment(每段重复) 沿轨迹重复纹理（每个轨迹段重复一次）。要调整平铺率，请使用 Material.SetTextureScale() Generate Lighting Data(生成照明数据) 如果启用此属性，Unity 在构建轨迹几何体时包含法线和切线。这样，轨迹几何体就可以使用采用了场景光照的材质 Shadow Bias(阴影偏离) 设置沿着光照方向的阴影移动量以消除阴影瑕疵 Materials(材质) # Trail Renderer Inspector中的Materials部分列出了Trail Renderer当前使用的材质。如果将多个材质应用于轨迹渲染器，则会为每个材质渲染一次\n属性 功能 Size(大小) 指定Trail Renderer中的Materials材质数量。如果减小Materials列表大小，Unity 会删除列表末尾的元素 Element(元素) Trail Renderer中的Materials列表（以数字顺序排列） Lighting(照明) # Lighting部分包含的属性用于指定此轨迹渲染器 (Trail Renderer) 如何在 Unity 中与光照相互影响\n属性 功能 Cast Shadows(投射阴影) 指定在合适的光源照射在轨迹上时该轨迹是否以及如何投射阴影 Off(关闭) 轨迹不会投射阴影。 On(开启) 投射阴影的光源照在轨迹上时，该轨迹将投射阴影 Two Sided(双面) 轨迹从任一侧投射双面阴影。Enlighten和渐进光照贴图 (Progressive Lightmapper)不支持双面阴影 Shadows Only(仅阴影) 轨迹的阴影可见，但轨迹本身不可见 Receive Shadows(接受阴影) 启用此选项可使轨迹显示任何投射在轨迹上的阴影。仅当使用渐进光照贴图时才支持这个选项 Probes(探测器) # Probes部分包含与 光照探针 (Light Probes)和 反射探针 (Reflection Probes)有关的属性\n属性 功能 Light Probes(光照探测器) 设置此渲染器如何从光照探针系统接收光照 Off(关闭) 渲染器不使用任何插值光照探针 Blend Probes(混合探测器) 渲染器使用一个插值光照探针 Use Proxy Volume(使用代理体) 渲染器使用插值光照探针的 3D 网格 Custom Provided(自定义提供) 渲染器从 MaterialPropertyBlock 提取光照探针着色器 uniform 值 Proxy Volume Override(代理卷覆盖) 设置对另一个具有Light Probe Proxy Volume组件的游戏对象的引用。仅当Light Probes设置为Use Proxy Volume时，此属性才可见 Reflection Probes(反射探测器) 设置渲染器如何从反射探针系统接收反射 Off 禁用反射探针。Unity 将天空盒用于反射 Blend Probes 启用反射探针。混合仅在反射探针之间发生。在室内环境中，如果角色可能在具有不同光照设置的区域之间过渡，此设置会很有用 Blend Probes and Skybox 启用反射探针。混合发生在反射探针之间或反射探针与默认反射之间。这对于室外环境很有用 Simple 启用反射探针，但存在两个重叠的探针体积时，反射探针之间不会发生混合 Anchor Override(锚点覆盖) 设置变换组件，在使用光照探针或反射探针系统时由 Unity 用来确定插值位置。默认情况下，这个位置是渲染器几何体的包围盒中心 Additional Settings(其他设置) # 属性 功能 Motion Vectors(运动矢量) 设置是否使用运动矢量来跟踪此渲染器从一帧到下一帧的每像素屏幕空间运动。使用此信息可以应用后期处理效果，例如运动模糊。请注意，并非所有平台都支持运动矢量 Camera Motion Only(仅摄像机运动) 仅使用摄像机移动来跟踪运动 Per Object Motion(每对象运动) 使用特定通道来跟踪此渲染器的运动 Force No Motion(强制无动作) 不跟踪运动 Dynamic Occlusion(动态遮挡) 启用Dynamic Occlusion后，此渲染器在摄像机的视图中被静态遮挡物 (Static Occluder) 阻挡时，Unity 会剔除此渲染器\n禁用Dynamic Occlusion后，此渲染器在摄像机的视图中被静态遮挡物 (Static Occluder) 阻挡时，Unity 不剔除此渲染器。禁用Dynamic Occlusion可以实现诸如在墙后绘制角色轮廓之类的效果 Sorting Layer(排序图层) 此渲染器的排序图层(Tags and Layers)的名称 Order in Layer(图层顺序) 此渲染器在排序图层(Tags and Layers)中的顺序 "},{"id":32,"href":"/summary/anime/","title":"Animation","section":"Docs","content":"首先是制作动画，动画的制作一般是一个物品开关\n开关 # 物品开关即录制动画把一个物品打开 同时这个物品可以放在自己的身体部位上（物体绑骨），例如手部\n粒子特效一般也可以通过录制开关进行播放\n动作 # 动作动画一般是MMD的舞蹈动作或Pose动作，建议使用现成的，自己制作较为困难\n现成的 # 对于MMD舞蹈，一般可以使用相应的工具进行转换为Unity可以识别的文件，对于Pose动作一般有成品可以进行购买使用\n自行制作 # 如果使用Unity进行制作是不现实的（动作可以在动画窗口添加属性-Animator里找），可以在其他软件制作骨骼动画以导入Unity\n其他 # 例如物品移动，表情动画，Shader改变以改头发颜色等\n"},{"id":33,"href":"/summary/parameters/","title":"Parameters","section":"Docs","content":"过渡的条件可使用官方数值，只需要在”动画器-参数”添加类型和名字与官方数值相同的参数即可\n一、数值类型 # 在”动画器“中添加参数有四种类型\nFloat ：浮点数，可以理解为小数\nInt ：整数型，可以理解为整数\nBool ：布尔型，只有”True“和”False“两种取值\nTrigger ：触发器，和布尔型很像，但只能被设为true，一旦被过渡使用就会自动被设为false(好像在VRC中没用？)\n下表为VRChat数值类型(一个模型的“数值”上限为“256 bits”)\n数值类型 取值范围 存储占用 备注 int 0 ~ 255 8 bits Unsigned 8-bit int. float -1.0 ~ 1.0 8 bits Signed 8-bit minifloat bool True or False 1 bit 如果要做开关，动画器-参数中参数名字与类型要与VRC数值中一模一样\n二、官方数值总览 # (以下表格中文为我自己翻译，可能会有错误，仅翻译可能有用或我用过的参数)\nName(名字) Description(描述) Type(类型) Sync(同步) IsLocal True if the avatar is being worn locally, false otherwise Bool None Viseme(口型) Oculus viseme index (0-14). When using Jawbone/Jawflap, range is 0-100 indicating volume Int Speech Voice Microphone volume (0.0-1.0) Float Speech GestureLeft(左手手势) Gesture from L hand control (0-7) Int IK GestureRight(右手手势) Gesture from R hand control (0-7) Int IK GestureLeftWeight Analog trigger L (0.0-1.0)† Float IK GestureRightWeight Analog trigger R (0.0-1.0)† Float IK AngularY Angular velocity on the Y axis Float IK VelocityX(X方向速度) Lateral move speed in m/s Float IK VelocityY(Y方向速度) Vertical move speed in m/s Float IK VelocityZ(Z方向速度) Forward move speed in m/s Float IK Upright(高度) How “upright” you are. 0 is prone, 1 is standing straight up Float IK Grounded(地面) True if player touching ground(如果跳跃则为false) Bool IK Seated True if player in station Bool IK AFK Is player unavailable (HMD proximity sensor / End key) Bool IK Expression1 – Expression16 User defined param, Int (0–255) or Float (-1.0–1.0) Int / Float IK or Playable TrackingType See description below Int Playable VRMode Returns 1 if the user is in VR, 0 if they are not Int IK MuteSelf Returns true if the user has muted themselves, false if unmuted Bool Playable InStation Returns true if the user is in a station, false if not Bool IK 三、手势对应数值 # 用于制作手势触发动画\nIndex (数值) Gesture (手势) PC按键 0 Neutral (自然) Shift+F1 1 Fist (握拳) Shift+F2 2 HandOpen (张开手) Shift+F3 3 fingerpoint (指) Shift+F4 4 Victory (剪刀手) Shift+F5 5 RockNRoll (我爱你) Shift+F6 6 HandGun (手枪) Shift+F7 7 ThumbsUp (点赞) Shift+F8 注：PC 按键：左 Shift 为左手，右 Shift为 右手\n四、口型对应值 # 口型参考： Viseme Reference: Unity | Oculus Developers\n可用于制作说话触发动画\nViseme Parameter Viseme 0 sil 1 PP 2 FF 3 TH 4 DD 5 kk 6 CH 7 SS 8 nn 9 RR 10 aa 11 E 12 ih 13 oh 14 ou "},{"id":34,"href":"/summary/layers/","title":"Animator Layers","section":"Docs","content":"不同图层的状态可以同时发生，同一图层同时只能执行一个状态\n图层 # 点击+可以添加一个图层，点击图层旁边的齿轮图标，会弹出一个小窗口，可以设置该图层对应的参数\n属性 描述 Weight(权重) 这一层的权重，0代表该层权重是0（该层不生效），1代表该层权重为1（该层中的动画能完全表现） Mask(遮罩) 此层上使用的遮罩，可以限制动画的播放部位，例如只要播放上半身的动画，可以使用一个遮罩定义在上半身播放动画。设置后该图层上面会显示一个M的小图标 Blending 和其他层混合的模式 Override 覆盖上面的层中对应Mask的部位 Additive 会加在之前图层的动画之上 Sync 复用其他层中的状态机 IK Pass 反向动力学 状态 # 状态是指在图层中的小方框，当拖入动画时会自动变成的“东西”\n新建一个图层，可以看到三个状态\n状态名称 简述 Entry 入口，根据过渡进入默认状态 Any State 任意状态，只要条件满足，可任意跳转到过渡的状态 Exit 退出，返回到”Entry“ 添加状态 # 可以在空白处右键添加Empty(空状态)，也可以将动画文件拖到Animator窗口中添加一个状态\n如果当前在Project窗口选中了一个动画文件，可以通过右击右击的From Selected Clip创建一个状态，不过还是直接拖入更方便\n第一个创建的状态默认是橙色的，代表默认状态，Animator会在一开始就播放，如果状态中有动画，也会被播放\n颜色 # 橙色：默认状态，即进入就执行的动画\n灰色：可通过过渡达到条件执行的动画\n状态设置 # 每个状态都可以包含一个动画，处于该状态时，Animator组件所在的物体会播放动画，选中一个状态时，会有如下选项\n名称 描述 Motion 状态绑定的动画（Animation） 速度(Speed) 动画播放的速度 乘数(Multiplier) Speed * 指定参数（float）作为运行时的播放速度 Motion Time 单位化时间，指定参数（float，范围是0~1）作为动画播放时间(可使用此制作轮盘开关) 镜像(Mirror) 镜像播放，若打开”参数(Parameter)“：指定参数作（bool）为镜像的开关 周期偏移(Cycle Offset) 循环偏移量，可以用来同步循环的动画，使用单位化时间（范围是0~1），也可使用参数控制 Foot IK 只用于人形动画，角色的脚是否使用IK（反向动力学） Write Default 进入下一个状态时重置此状态所作的更改（初始化该状态没有用到的参数为默认值） Transition # 显示当前状态的过渡，选中后出现内容与在图层中选中一致\n名称 描述 Solo 选中则只生效当前过渡，其他将被禁用 Mute 选中则禁用当前过渡 如果同时选中Solo和Mute，Mute会优先生效\n过渡 # 表示状态之间的切换条件，一般会有一个或多个条件，用于从一个状态切换到另一个状态\n右击一个状态，Make Transition后选择另一个状态即可创建过渡，在过渡中可以添加相应条件\n名称 描述 Solo 选中则只生效当前过渡，其他将被禁用 Mute 选中则禁用当前过渡 如果同时选中Solo和Mute，Mute会优先生效\n多个出过渡时可调整位置(上下)以实现优先级(上方优先级高于下方)\n名称 描述 Name Field 名称框可以为过渡命名，用于区分俩个状态之间的多条过渡时很有用 Has Exit Time 是否有退出时间为条件 退出时间是一种特殊的过渡条件，它没有依赖参数，而是根据设置的退出时间点作为条件进行状态转换。\nSettings # 过渡的一些参数设置\n名称 描述 退出时间(Exit Time) 如果勾选了Has Exit Time，该参数可以设置，设置动画退出的单位化时间(单位：上一状态动画长度，如为物体打开动画/空动画可当成以秒为单位)。\n例如设置为0.75，代表动画播放到75%时为true，如果没有其他条件，会直接切换到下一个状态。\n如果exit time小于1，那么状态每次循环到对应位置的时候（不管动画是否设置为循环，状态总是循环的），该条件都会为true。比如第一次播放到75%，第二次播放到75%……时退出时间条件都会为true。\n如果exit time大于1，该条件只会检测一次。比如exit time为3.5，state的动画会在循环3次后，在播放到第4次的50%时为true。 固定持续时间(Fixed Duration) 勾选，下一项”过渡持续时间(Transition Duration)“以秒为单位\n取消勾选，下一项”过渡持续时间(Transition Duration)“以（前一个状态的）百分数计数，1为100% 过渡持续时间(Transition Duration) 过渡的过渡时间。两个状态在转换时，一般不会瞬间从一个状态转换到另一个状态，而是会经过平滑混合，这个属性就是设置了平滑混合的时间 过度偏移(Transition Offset) 状态开始播放时的时间偏移。即后一个状态从何处开始，值为后一个状态的百分数，1为100%\n例如设置为0.5，则转换到下一个状态时，会从50%的位置开始播放 过渡图 # 上面的参数不仅可以手动修改，也可以通过过渡图预览和修改\n中断源(Interruption Source) # 可以打断状态的过渡，但尽量避免使用，比较复杂\n例如以下图层\nCurrent State(当前状态) # 默认情况下，当A到C的切换触发后，状态机开始切换到C，在切换到C之前无法被改变。但是，如果将A-\u0026gt;C的过渡的中断源(Interruption Source)改为Current State，A-\u0026gt;C的过渡就可以被A上的一些过渡中断\n在状态A上的过渡如下：\n一些的原因：若勾选Ordered Interruption则只有优先级比A-\u0026gt;B高的才能打断\n过渡的优先级从上到下依次降低，即优先级A-\u0026gt;B\u0026gt;A-\u0026gt;C\u0026gt;A-\u0026gt;D\n如果勾选Ordered Interruption\n如果此时A-\u0026gt;B的切换触发，则会中断A-\u0026gt;C，触发A-\u0026gt;B\n但如果此时A-\u0026gt;D的切换触发，不会中断A-\u0026gt;C，还是触发A-\u0026gt;C\n如果不勾选Ordered Interruption\n此时A-\u0026gt;B或A-\u0026gt;D的切换触发都会中断A-\u0026gt;C\n如果A-\u0026gt;B和A-\u0026gt;D同时触发，则会优先激活A-\u0026gt;B，因为优先级较高\nNext State(下一状态) # 如果将A-\u0026gt;B的过渡的中断源(Interruption Source)改为Next State，A-\u0026gt;B和A-\u0026gt;D就不能中断A-\u0026gt;C了\n如果我们激活A-\u0026gt;B后，又激活B-\u0026gt;D，那么A-\u0026gt;C的过渡会被中断，转而切换到D\n状态B上的过渡顺序也会有影响，但此时Ordered Interruption无法勾选(因为A-\u0026gt;B是在状态A上，不在状态B上，不参与B的排序)。状态B上的过渡顺序会决定同时触发时会使用哪一个过渡，例如下图过渡\n如果B-\u0026gt;C和B-\u0026gt;D同时触发，则优先执行B-\u0026gt;C\nCurrent State Then Next State(当前状态然后下一状态) # 如果将A-\u0026gt;B的过渡的中断源(Interruption Source)改为Current State Then Next State，则状态A与状态B的过渡都会被考虑在内\n如果A-\u0026gt;B切换时，同时激活的A-\u0026gt;C, A-\u0026gt;D, B-\u0026gt;C和B-\u0026gt;D（不勾选Ordered Interruption）\n因Current State Then Next State(当前状态然后下一状态)，先看状态A的过渡，由于A-\u0026gt;C的优先级比A-\u0026gt;D高，则将执行A-\u0026gt;C，因结果已出，不用再考虑下一状态B\nCurrent State Then Next State(当前状态然后下一状态) # 与上一个相反\n总结 # 名称 描述 Ordered Interruption 优先级高于当前过渡才可以打断 无(None) 不可打断 Current State 前一个状态开始的状态过渡可以打断正在进行的状态过渡 Next State 从后一个状态开始的状态过渡可以打断正在进行的状态 Current State Then Next State 决定哪个动画State上的过渡节点优先权更高，先看前一个State的优先级如果没有被触发，再看后一个State的优先级，来达到不同的融合与打断效果 Next State Then Current State 决定哪个动画State上的过渡节点优先权更高，与上一个相反 Condition # 过渡条件，一个过渡可以有一个条件，也可以有多个条件，甚至没有条件\n如果没有条件，但是勾选了Has Exit Time，那么Exit Time会被作为状态退出的条件，到达Exit Time时，会切换到下一个状态\n如果有一个或多个条件，需要同时满足这些条件才能切换到下一个状态\n条件可以通过参数设置，具体如下\n参数类型 描述 Int型 可选择Greater（\u0026gt;）、Less（\u0026lt;）、Equals（==）、NotEqual（!=）指定的数作为过渡条件 Float型 可选择Greater（\u0026gt;）、Less（\u0026lt;）指定的数作为过渡条件 Bool型 可选择指定值（true or false）作为过渡条件 Trigger 条件为true时触发状态过渡 如果Has Exit Time勾选了，并且过渡还有一个或多个条件，那么过渡需要同时满足到达Exit Time，同时条件全为true，才会切换到下一个state\n一个过渡至少要有一个条件（Has Exit Time可以作为一个条件），否则过渡将会被忽略(不会被执行进入下一个状态)\n注：Trigger貌似在VRChat中没有作用，至少我不知道\n"},{"id":35,"href":"/summary/menu/","title":"VRChat Menu","section":"Docs","content":" 类型 介绍 Button(按钮) 值只改变一次，通常大约一秒钟 Toggle(切换) 点击会变为设定值，直至关闭 Sub Menu(子菜单) 下一级菜单，设置参数类似”Toggle” Two Axis Puppet(双轴控制) 两个参数(float)控制垂直与水平(-1.0~1.0) Four Axis Puppet(四轴控制) 四个参数(float)控制上下左右(0~1.0) 可用来制作摇尾巴 Radial Puppet(百分比转盘) 一个参数控制，通常用来改变颜色或换衣服 以上为个人理解，以下为官方原文\nButton – Sets a parameter when clicked, then resets after the sync/reset has been sent– usually after about a second. Cannot be held down.\nToggle – Sets a parameter when the toggle is on, resets when the toggle is turned off\nSub-Menu\n– Opens another Expression Menu. Additionally it may also set a parameter when entered, if so that parameter is reset to zero when you exit that menu.\nImportant note: You can put sub-menus into sub-menus! Two Axis Puppet – Opens an axis puppet menu that controls two parameters depending on the joystick position. The parameters are mapped to vertical and horizontal. The float values range from -1.0 to 1.0.\nFour Axis Puppet – Opens an axis puppet menu that controls four parameters depending on the joystick position. The parameters are mapped in order, up, right, down, left. The float values are 0.0 to 1.0.\nRadial Puppet – Open a radial puppet menu that controls a single parameter, kind of like a progress bar that you can fill!\n"},{"id":36,"href":"/about/","title":"关于","section":"Docs","content":" 历史更新记录 # 2024.12.31\n转换至 Hugo Book，修复部分错误，调整部分文章符合 markdownlint 规范\n2024.07.31\n将博客网站从 Typecho 迁移到 Hexo，挂在 Github 上\n2023.11.27\n将原本放在网盘的文件放在 Github 所有图片均使用 jsd.cdn.zzko.cn 外链\n网站使用 CF 减速\n关于博客网站 # 2032 年前应该为 http://vrc.yexca.net\n我从接触 VRChat 到做出网站其实只有大概一个半月的时间，肯定会有许多问题我没有遇到或无法解决，请见谅\n然后就是里面的文章可能就那样不会去修改了吧\n目前已经更换网站系统，文章 (如果有) 将继续发布，原有文章链接替换完毕，不再更新\n如果想继续访问可以在本地部署，仓库： https://github.com/yexca-VRChat/blog\n在 2024.07.31 部署在 Github 上了，上面仓库是 Typecho 的 Docker 镜像\n关于此网站 # 这个网站是部署在 Github 上的，主要是在做网盘网站时接触了Markdown觉得很好用，又得知可以直接使用Markdown进行建网站便尝试了一下，以后更新应该会在这里吧，毕竟WordPress打开写文章太难受了 (我本可以忍受WordPress，如果我不曾遇见Markdown)\n现在两网站将一起更新，但此网站会更快点？\n考虑到博客网站修改，形式或者说功能？与此网站冲突，特修改侧边样式，将模块放到前面\n记录 # 这里是我为什么做这些，仅记录使用\n起因\n和朋友开玩笑式说自己要去做教程，然后他很支持\n不过说实话当时知道的还很少，就想着随便写写吧，反正没人看\n文章\n然后我就去做了博客网站，这个网站刚开始名字是 VRChat教程，在制作过程查阅资料时发现自己知道的其实非常有限，于是连夜更改网站名称\n视频\n起初只是想写文章，但有些东西是文章无法表现出来的，于是便去试着做了视频\n令我没想到的是居然有人会看我的视频(doge)，然后后面的文章写的也不是特别随意了\n在看到很多人的评论之类的东西后感觉 (自己遇到的问题好少啊) 挺开心的\n然后也渐渐看到了一些更深入的视频，再次意识到了自己的弱小\n现在 - 2024.07.31\n也不知道这么多年过去了游戏更新没，还适用吗。不过当时的我也是看着相对于当时几年前的文章，想必大佬们可以从我浅薄的文章中融会贯通吧\n关于我 # 如果你想了解我的话： https://lit.link/yexca\n"},{"id":37,"href":"/references/","title":"参考资料","section":"Docs","content":"这边将列出我做此系列东西所看过的东西，非常感谢所有大佬所做的付出，可能会有不全，毕竟刚开始也没想过自己会去写文章，请见谅\n与此同时，我也将把各个文章参考资料部分删除\n文章 # VRChat官方文档： VRChat 后来才知道官方文档，全英文，机翻读了大概\nBlender官方文档： Blender2.93参考手册 众所周知，官方文档永远看不懂\nUnity 用户手册(2019.4 LTS)\nVRChat模型制作及上传总篇(201912) - 星空月零 - 博客园\n看的第一篇文章，当时Google搜vrchat上传mmd模型第一个结果，虽然非常全面但教程较旧\nUnity Animator动画状态机 - 1024搜-程序员专属的搜索引擎 介绍了Unity动画方面各个功能~~（虽然最后那部分我看不懂）~~\nWrite Defaults的作用_煮粥侠_99的博客-CSDN博客 文章VRLabs Marker介绍的参考\nBlender - 2.8x - Screencast Keys (v3.0) - 屏幕显示按键信息插件介绍以及安装 Blender换头视频的显示按键插件参考\n【心得】Dynamic Bone (\u0026amp;乳搖) 研究筆記 我看不懂，但我大受震撼，三篇文章，动骨碰撞的添加\nUnity动画系统详解3：如何播放、切换动画？ - 知乎 (zhihu.com) 之前看不懂的部分看懂啦~\nUnity Cloth 布料模擬教學\nUnity粒子系统简单常用功能介绍-腾讯游戏学堂\nLinux安装指定版本的Unity3D_Frank（Zhiyang-Dou）的博客-CSDN博客\n在blender2.92中删除合并重叠点相邻点的方法-百度经验\n文章所能表达的东西实在有限，有些东西是没视频直观的，然后在一些视频网站看到了许多大佬做的视频教程\n视频-BiliBili # Blender新手入门基础教程 （看了以后和没看一样），只是为了VRChat，个人不建议去观看\n【VRChat】模型教程合集 模型上传 改模 修改衣服 武器开关 固定物品 座椅 | 2022.2.20更新 由 云吞大佬制作，也是我看的第一个VRChat上传模型相关视频，非常详细\n【VRChat \u0026amp; unity 教程】模型上传基础\u0026amp;常见效果教程合集~(持续更新中) 由 雨云大佬制作，虽是SDK2时期的教程，但也很好\nVRChat 模型交互系统新动骨教程（Physbone，Contact） 由 Circes大佬制作，做交互系统的文章时了解了一下，让我有了更清晰的认知\n【VRCHAT教程】VRC 3.0 Avatar模型全面详细功能解析 专为萌新和初级进阶玩家设计的unity教程 2.0转3.0详细教学 由 陌颜大佬制作，这是对我帮助最大的视频~~（但却是我最后搜到的）~~，清晰的讲述了SDK3\n【VRChat】傻瓜萌新式上传模型教程 \u0026amp; 动态与碰撞制作 由 宇焰大佬制作，清晰得讲述了MMD模型的转换与上传\n【VRC工具箱1.1】VRChat衣柜插件大更新！？简单实用的Unity换装插件了解一下 由 如梦大佬制作，为VRC工具箱的发布视频\n[vrchat改模型]10分钟就能弄懂的unity给模型换衣服的原理 由 ShineTrick閃輝詭詭大佬制作，清晰讲述了Unity中换衣服，看到这视频前我以为不适配衣服只能去Blender修改\n成为VRChat接头大佬第二弹! 进阶接头教学以及脖子接面教学 [LoliKami] 由 LoliKamiGod大佬制作，换头文章/视频的主参考\nVRChat 运用Blender作模型的改模（2.82版本） 由 Yami黯影大佬制作，改模的完整录屏，换头文章/视频的部分操作参考\n这大佬和我一样喜欢用YouTube听歌\n【VRchat教程】白嫖网上的特效+如何自制和修改粒子特效(讲的很迷）\nVRChat模型教程，从换头到修改身体比例与速成布料。做模型教程界的泥石流\n视频-Youtube # VRChat Avatar Dynamics Tutorial - PhysBones 新动骨的介绍\nVRChat稍微進階的動畫製作教學 [LoliKami] 我也不知道他讲的啥\nCustom Avatar Crouch and Prone Animation Poses for VRChat Base层的修改\n2022 VRChat使用Avatar 3.0完整模組製作教學 (Unity 2019 \u0026amp; Blender 2.93+) [LoliKami] 只看了动骨部分，不过是老动骨了\nVRChat Avatar 3.0 Tutorial - Toggling Props \u0026amp; Accessories 我也不知道他讲了啥\nVRChat - Avatar 3.0 State Behaviors Explained! VRC脚本的介绍~~（看了和没看一样）~~\nVRChat Avatar 3.0 Tutorial - Color Change (Radial Puppet) 改变颜色，不过使用的BlendTree\n最后 # 因视频平台历史记录有限以及我的电脑重装过系统，浏览器记录也清除的原因，除Youtube外仅列出了我所能想起并能找到的所有链接，如果遇到其他有帮助的视频或之前看过这里没有的我将加入到这里\n"}]